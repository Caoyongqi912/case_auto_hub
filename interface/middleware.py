#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : sender# @Software: PyCharm# @Desc:import asyncioimport ioimport jsonimport osfrom typing import Any, Dict, List, TypeVar, Tuple, Optionalfrom httpx import Response, Timeoutfrom app.mapper.interface import InterfaceGlobalHeaderMapperfrom app.model.interface import InterfaceModelfrom enums import InterfaceRequestTBodyTypeEnum, InterfaceRequestMethodEnumfrom utils import GenerateTools, MyLoguru, logfrom common.fakerClient import FakerClientfrom common.httpxClient import HttpxClientfrom .starter import APIStarterimport reimport mimetypesLOG = MyLoguru().get_logger()f = FakerClient()Interface = TypeVar('Interface', bound=InterfaceModel)class HttpxMiddleware(HttpxClient):    """    httpx 处理请求信息    替换变量    """    def __init__(self, variables: Dict[str, Any], starter: APIStarter):        self.variables = variables        self.starter = starter        super().__init__(logger=self.starter.send)    async def transform_target(self, target: Any):        """        递归转换目标对象中的变量        :param target: 需要转换的目标（字符串/字典/列表/元组）        :return: 转换后的对象        """        if isinstance(target, str):            return await self._transformStr(target)        if isinstance(target, dict):            return await self._transFormObj(target)        if isinstance(target, list):            return await self._transFormList(target)        if isinstance(target, tuple):            return await self._transFormTuple(target)        else:            return target    async def _transformStr(self, target: str) -> str:        """        字符串替换        支持格式：        - {{$faker}}：使用Faker生成数据        - {{variable}}：使用自定义变量        - 混合文本中的变量：如"prefix{{variable}}suffix"        """        if target.startswith("{{") and target.endswith("}}"):            # 处理 {{$xx}} 格式变量            extractKey = target[2:-2]            if extractKey.startswith("$"):                extractKey = extractKey[1:]                return f.value(extractKey)            return self.variables.get(extractKey, target)        else:            pattern = r"\{\{(.*?)\}\}"            return re.sub(pattern, lambda match: str(self.variables.get(match.group(1), match.group(0))), target)    async def _transFormObj(self, target: Dict[str, Any]) -> Dict[str, Any]:        """        字典替换        :param target        """        """并行转换字典中的值"""        if not target:            return target        keys, values = zip(*target.items())        transformed_values = await asyncio.gather(*[            self.transform_target(v) for v in values        ])        return dict(zip(keys, transformed_values))    async def _transFormList(self, target: List[Any]) -> List[Any]:        """        列表替换        """        """并行转换列表中的元素"""        return await asyncio.gather(*[            self.transform_target(item) for item in target        ])    async def _transFormTuple(self, target: Tuple[Any, ...]) -> Tuple[Any, ...]:        """        元组替换        如果是附件 跳过        """        transformed_items = []        for item in target:            if isinstance(item, io.BufferedReader):                transformed_items.append(item)                continue            transformed = await self.transform_target(item)            transformed_items.append(transformed)        return tuple(transformed_items)    async def set_req_info(self, interface: Interface):        """        处理并构建HTTP请求信息        Args:            interface: 接口对象，包含请求方法、头信息、参数等        Returns:            包含完整请求信息的字典，可用于httpx等HTTP客户端        """        # 初始化请求数据字典        _request_data = {            'read': interface.response_timeout,            'connect': interface.connect_timeout,            'follow_redirects': bool(interface.follow_redirects),            InterfaceRequestTBodyTypeEnum.HEADERS: await self._prepare_headers(interface),  # 处理请求头        }        # 根据请求方法处理参数或请求体        if interface.method == InterfaceRequestMethodEnum.GET:  # GET            await self._process_get_params(_request_data, interface)        else:            await self._process_request_body(_request_data, interface)        # 并行转换请求数据中的变量        await self._transform_request_data(_request_data)        return _request_data    @staticmethod    async def _prepare_headers(interface: Interface) -> Dict[str, str]:        """准备请求头（合并全局和接口特定头）"""        headers = {}        # 添加全局头        global_headers = await InterfaceGlobalHeaderMapper.query_all()        for header in global_headers:            headers.update(header.map)        # 添加接口特定头        if interface.headers:            headers.update(GenerateTools.list2dict(interface.headers))        return headers    @staticmethod    async def _process_get_params(_request_data: Dict[str, Any], interface: Interface) -> None:        """处理GET请求参数"""        if interface.params:            _request_data[InterfaceRequestTBodyTypeEnum.PARAMS] = GenerateTools.list2dict(interface.params)    async def _process_request_body(self, request_data: Dict[str, Any], interface: Interface) -> None:        """处理非GET请求的请求体"""        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null:            return        body_data, content_type = await self._filter_request_body(interface)        if content_type:            request_data[InterfaceRequestTBodyTypeEnum.HEADERS]["Content-Type"] = content_type        if body_data:            request_data.update(**body_data)    async def _filter_request_body(self, interface: Interface) -> Tuple[Dict[str, Any] | None, str | None]:        """根据接口请求体类型处理请求体数据        Args:            interface: 接口对象，包含请求体相关数据        Returns:            Tuple[处理后的请求体字典, Content-Type字符串]            如果不需要请求体则返回 (None, None)        """        log.info(f"request body = {interface.body}")        log.info(f"request body_type = {interface.body_type}")        match interface.body_type:            case InterfaceRequestTBodyTypeEnum.Raw:                return await self._prepare_raw_body(interface)            case InterfaceRequestTBodyTypeEnum.UrlEncoded:                return await self._prepare_form_urlencoded(interface)            case InterfaceRequestTBodyTypeEnum.Data:                return await self._prepare_form_data(interface)            case _:                log.warning(f"Unsupported body type: {interface.body_type}")                return None, None    async def _transform_request_data(self, request_data: Dict[str, Any]) -> None:        """并行转换请求数据中的变量"""        transform_tasks = [            self.transform_target(value)            for value in request_data.values()            if value is not None        ]        transformed_values = await asyncio.gather(*transform_tasks)        for key, value in zip(request_data.keys(), transformed_values):            if value is not None:                request_data[key] = value    @staticmethod    async def _prepare_raw_body(interface: Interface) -> Tuple[Dict[str, Any], str]:        """准备原始请求体（JSON/Text）"""        if interface.raw_type == "json":            return (                {InterfaceRequestTBodyTypeEnum.JSON: interface.body},                "application/json"            )        else:  # text            return (                {InterfaceRequestTBodyTypeEnum.Content: json.dumps(interface.body)},                "text/plain"            )    @staticmethod    async def _prepare_form_urlencoded(interface: Interface) -> Tuple[Dict[str, Any], str]:        """准备URL编码表单数据"""        form_data = GenerateTools.list2dict(interface.data)        return (            {InterfaceRequestTBodyTypeEnum.FORM_DATA: GenerateTools.list2dict(interface.data)},            "application/x-www-form-urlencoded"        )    async def _prepare_form_data(self, interface: Interface) -> Tuple[Dict[str, Any], Optional[str]]:        """准备多部分表单数据（支持文件上传）"""        files = {}        data = {}        form_data = GenerateTools.list2dict(interface.data)        for key, value in form_data.items():            # 附件类型            if str(value).startswith(str(interface.uid)):                file_info = await self._prepare_file_upload(key, value)                if file_info:                    files[key] = file_info            else:                data[key] = value        return (            {InterfaceRequestTBodyTypeEnum.FORM_FILES: files,             InterfaceRequestTBodyTypeEnum.FORM_DATA: data},            None  # Content-Type将由httpx自动设置        )    @staticmethod    async def _prepare_file_upload(key: str, value: Any) -> Optional[Tuple]:        """准备文件上传数据"""        from utils.fileManager import API_DATA        files = {}        filepath = os.path.join(API_DATA, value)        log.debug(f"filepath = {filepath}")        try:            # 确保文件存在并可读            if not os.path.exists(filepath):                log.error(f"文件不存在: {filepath}")                return            if not os.access(filepath, os.R_OK):                log.error(f"文件不可读: {filepath}")                return            # 获取文件的 MIME 类型            mime_type, _ = mimetypes.guess_type(str(filepath))            mime_type = mime_type or 'application/octet-stream'  # 默认类型            fileName = os.path.basename(filepath).split("_")[-1]            with open(filepath, 'rb', encoding="utf-8") as f:                if f:                    files[key] = (key, f, mime_type)                    log.debug(f"文件 {fileName} 已添加到上传列表，MIME类型 = {mime_type}")                else:                    log.error(f"无法打开文件 {filepath}")                    return None        except Exception as e:            log.exception(f"处理文件 {filepath} 时出错: {str(e)}")            return None