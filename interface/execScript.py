#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : execFunc# @Software: PyCharm# @Desc:from typing import List, Mapping, Any, Dictimport timefrom datetime import datetime, timedeltafrom faker import Fakerfrom utils import MyLoguru, GenerateToolsdef get_vars(content: str) -> List[str]:    """    获取变量    """    import re    pattern = r'(\w+)\s*='    matches = re.findall(pattern, content)    variables = [match.strip() for match in matches]    return variablesclass TargetOPT:    Before = "4"    After = "3"class ExecScriptForInterface:    faker = Faker(locale="zh_CN")    def __init__(self, funcStr: str, log: Any = None):        self.funcStr = funcStr        self.variables = {}        if log is None:            self.log = MyLoguru().get_logger()        else:            self.log = log        self.local_vars = {"log": self.log.info,                           "timestamp": self.__timeStamp,                           "faker": self.faker,                           "execute_sql": self.execute_sql,                           "getVar": self.get_var,                           "date": self.__calculate_date}    def exec_beforeFunc(self) -> Dict[str, Any]:        """        执行前置方法        """        self.log.info(f" 🚩🚩🚩🚩 开始执行前置方法 🚩🚩🚩🚩")        _vars = get_vars(self.funcStr)        self._exec(_vars)        self.log.info(f"前置方法执行完成 ✅✅✅✅\n")        return self.variables    def get_var(self, key):        for k, v in self.variables.items():            if k == key:                return v        return None    def _exec(self, varList):        try:            exec(self.funcStr, self.local_vars)        except Exception as e:            self.log.info(f"执行方法报错 <{str(e)}>")        for variable_name, variable_value in self.local_vars.items():            if variable_name in varList:                obj = {variable_name: variable_value}                self.log.info(f"方法 变量 👉👉👉👉: {obj}")                self.variables.update(obj)                self.log.info(self.variables)    @staticmethod    def __timeStamp(t: str = None) -> int | None:        """        返回对应时间戳        ：param t +1s 秒  +1m 分 +1h分钟        """        if t is None:            return int(time.time() * 1000)        ts = int(t[1:-1])        unit = t[-1]        if t.startswith("+"):            match unit:                case "s":                    return int(time.time()) + int(ts[:-1])                case "m":                    return int((datetime.now() + timedelta(minutes=int(ts[:-1]))).timestamp())                case "h":                    return int((datetime.now() + timedelta(hours=int(ts[:-1]))).timestamp())        elif t.startswith("-"):            match unit:                case "s":                    return int(time.time()) - int(ts[:-1])                case "m":                    return int((datetime.now() - timedelta(minutes=int(ts[:-1]))).timestamp())                case "h":                    return int((datetime.now() - timedelta(hours=int(ts[:-1]))).timestamp())        else:            return None    @staticmethod    def __calculate_date(t: str = None) -> str | None:        current_date = datetime.today().strftime("%Y-%m-%d")        if not t:            return current_date        ts = int(t[1:-1])        if t.startswith("+"):            delta = {"d": timedelta(days=ts),                     "m": timedelta(weeks=ts * 4),                     "y": timedelta(days=ts * 365)}            return (datetime.today() + delta[t[-1]]).strftime("%Y-%m-%d")        elif t.startswith("-"):            delta = {"d": timedelta(days=ts),                     "m": timedelta(weeks=ts * 4),                     "y": timedelta(days=ts * 365)}            return (datetime.today() - delta[t[-1]]).strftime("%Y-%m-%d")        else:            return None    @staticmethod    def execute_sql(db: str, sql_content: str):        result = []        # result = MyOracle(city=db).fetchall_sql(sql_content)        return result# class MyExecFunc:#     """#     接口执行 python 函数#     """#     response: Response#     faker = Faker(locale="zh-cn")##     def __init__(self, funcStr: str = None, sender: Sender = None, varList: List[Mapping[str, Any]] = None):#         """#         :param funcStr#         :param sender#         :param varList#         """#         self.funcStr = funcStr#         self.varList = varList#         self.infos = []#         self.assertInfo = []#         self.__sender_instance = sender#         self.local_vars = {"log": self.__log,#                            "timestamp": self._timeStamp,#                            "faker": self.faker,#                            "execute_sql": self.execute_sql,#                            "getVar": self.get_var,#                            "date": self.calculate_date}##     def _exec(self, varList):#         try:#             exec(self.funcStr, self.local_vars)#         except Exception as e:#             self.__log(f"执行方法报错 <{str(e)}>")#         for variable_name, variable_value in self.local_vars.items():##             if variable_name in varList:#                 log.debug(f"{variable_name} = {variable_value}")#                 obj = {variable_name: variable_value}#                 self.__log(f"方法 变量 👉👉👉👉: {obj}")#                 self.infos.append({"key": variable_name, "value": variable_value})##     def exec_afterFunc(self, response: Response):#         """#         执行funcStr#         :param response 响应#         :param vars 变量#         """#         if response:#             self.response = response#         self.__log(f"️ 🚩🚩🚩🚩 开始执行后置方法 🚩🚩🚩🚩")#         if self.funcStr:#             varList = get_vars(self.funcStr)#             self.local_vars['response'] = response#             self.local_vars['do_assert'] = self.__after_assert#             self._exec(varList)#             self.__log(f"后置方法执行完成 ✅✅✅✅\n")#             self.infos = [{**i, "target": TargetOPT.After} for i in self.infos if self.infos]#         log.debug(self.infos)##         return self.infos##     def __after_assert(self, actual: Any, opt: str, expect: Any, desc: str = "do_assert FUNC"):#         """#         后置方法校验#         :param actual:实际值#         :param opt:校验方法#         :param expect 预期值#         :param desc 断言描述#         """#         if not actual or not opt or not expect:#             self.__log("assert 缺少参数")#             return#         if not self.response:#             self.__log("assert 无响应 response")#             return#         from Utils.APIUtils.myAssert import MyAssert#         try:#             assert_instance = MyAssert("后置Func 校验", response=self.response)#             assert_instance.execAssert(actual=actual, opt=opt, expect=expect)#             self.__log(f"assert 断言成功 预期值 【{expect}】 实际值 【{actual}】")#             self.assertInfo.append(#                 {"actual": actual, "assertOpt": opt, "expect": expect, "extraOpt": "AfterFunc",#                  "extraValue": "assert", "desc": desc,#                  "result": True})##         except Exception as e:#             log.exception(e)#             self.__log(f"assert 断言失败 预期值 【{expect}】 实际值 【{actual}】")#             self.assertInfo.append(#                 {"actual": actual, "assertOpt": opt, "expect": expect, "extraOpt": "AfterFunc",#                  "extraValue": "assert", "desc": desc,#                  "result": False})##     def exec_beforeFunc(self):#         """#         执行前置方法#         """#         self.__log(f" 🚩🚩🚩🚩 开始执行前置方法 🚩🚩🚩🚩")#         if self.funcStr:#             varList = get_vars(self.funcStr)#             self._exec(varList)#         self.__log(f"前置方法执行完成 ✅✅✅✅\n")#         self.infos = [{**i, "target": TargetOPT.Before} for i in self.infos if self.infos]#         return self.infos##     def get_var(self, key):#         log.debug(f"get var {key}")#         for var in self.varList:#             if var["key"] == key:#                 return var["value"]#         return None##     @staticmethod#     def _timeStamp(t: str = None) -> int | None:#         """#         返回对应时间戳#         ：param t +1s 秒  +1m 分 +1h分钟#         """##         if t is None:#             return int(time.time() * 1000)#         ts = int(t[1:-1])#         unit = t[-1]##         if t.startswith("+"):#             match unit:#                 case "s":#                     return int(time.time()) + int(ts[:-1])#                 case "m":#                     return int((datetime.now() + timedelta(minutes=int(ts[:-1]))).timestamp())#                 case "h":#                     return int((datetime.now() + timedelta(hours=int(ts[:-1]))).timestamp())#         elif t.startswith("-"):#             match unit:#                 case "s":#                     return int(time.time()) - int(ts[:-1])#                 case "m":#                     return int((datetime.now() - timedelta(minutes=int(ts[:-1]))).timestamp())#                 case "h":#                     return int((datetime.now() - timedelta(hours=int(ts[:-1]))).timestamp())#         else:#             return None##     @staticmethod#     def calculate_date(t: str = None) -> str | None:#         current_date = datetime.today().strftime("%Y-%m-%d")#         if not t:#             return current_date##         ts = int(t[1:-1])##         if t.startswith("+"):#             delta = {"d": timedelta(days=ts),#                      "m": timedelta(weeks=ts * 4),#                      "y": timedelta(days=ts * 365)}#             return (datetime.today() + delta[t[-1]]).strftime("%Y-%m-%d")##         elif t.startswith("-"):#             delta = {"d": timedelta(days=ts),#                      "m": timedelta(weeks=ts * 4),#                      "y": timedelta(days=ts * 365)}#             return (datetime.today() - delta[t[-1]]).strftime("%Y-%m-%d")##         else:#             return None#if __name__ == '__main__':    func = """a = "cyq"d = timestamp()f = faker.name()"""    e = ExecScriptForInterface(        funcStr=func,        variables={"b": 2, "c": 3},    )    e.exec_beforeFunc()