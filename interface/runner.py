import asyncioimport jsonfrom typing import List, Dict, Any, Mapping, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.interface.interfaceVarsMapper import InterfaceVarsMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.mapper.project.env import EnvMapperfrom app.model.interface import InterfaceModel, InterfaceCaseResultModel, InterFaceCaseModel, InterfaceTaskResultModel, \    InterfaceVariablesfrom app.model.interface.InterfaceCaseStepContent import InterfaceCaseStepContent, InterfaceConditionfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnum, \    InterfaceCaseErrorStepfrom enums.CaseEnum import CaseStepContentTypefrom play.starter import UIStarterfrom utils import MyLoguru, GenerateToolsfrom app.mapper.interface import InterfaceMapper, InterfaceConditionMapper, InterfaceGroupResultMapper, \    InterfaceConditionResultMapperfrom app.mapper.interface.interfaceCaseMapper import InterfaceCaseMapperfrom utils.execDBScript import ExecDBScriptfrom interface.exec import *from utils.variableTrans import VariableTransfrom .middleware import HttpxMiddlewarefrom .starter import APIStarterfrom .writer import InterfaceAPIWriterlog = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)InterfaceCase = TypeVar('InterfaceCase', bound=InterFaceCaseModel)Interfaces = List[Interface]InterFaceCases = List[InterfaceCaseStepContent]class InterFaceRunner:    response: Response | str = None    def __init__(self, starter: APIStarter | UIStarter):        self.starter = starter        self.vars = VariableTrans()        self.sender = HttpxMiddleware(self.vars, self.starter)    async def execute_interface_by_ui(self, interface: Interface, ui_vars: Dict[str, Any] | None = None):        """        ui 侧执行接口        :param interface：接口对象        :param ui_vars: ui 变量        """        if ui_vars:            await self.vars.add_vars(ui_vars)        result, _ = await self.__execute_interface(interface)        return result, _    async def try_interface(self, interface: int) -> Mapping[str, Any]:        """        执行单个接口请求调试        无变量、有前置方法、        需要返回response        """        interface = await InterfaceMapper.get_by_id(ident=interface)        result, _ = await self.__execute_interface(interface)        return result    async def get_interface(self, interfaceId: int, use_var: bool = False):        """获取接口信息"""        interface: Interface = await InterfaceMapper.get_by_id(ident=interfaceId)        # 自定义环境        if interface.env_id == -1:            from utils import Tools            parse = Tools.parse_url(interface.url)            url = parse.path            host = f"{parse.scheme}://{parse.netloc}"        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            host = env.host            url = interface.url            if env.port:                host += f":{env.port}"        if use_var:            # 1、前置变量参数            await self.__exec_before_params(interface.before_params)            # 2、执行前置函数            await self.__exec_script(interface.before_script)            # 3.前置sql            await self.__exec_before_sql(interface)            url = await self.vars.trans(target=url)        info = await self.sender.set_req_info(interface)        info.pop("follow_redirects")        info.pop("read")        info.pop("connect")        return {            "name": interface.name,            "method": interface.method.lower(),            "url": url,            "host": host,            "asserts": interface.asserts,            **info        }    async def try_group(self, groupId: int):        """        执行接口组        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=groupId)        results = []        for interface in interfaces:            await self.starter.send(f"✍️✍️  Execute    {interface}")            result, _ = await self.__execute_interface(interface)            results.append(result)        return results    async def run_interface_by_task(self, interface: Interface, taskResult: InterfaceTaskResultModel) -> bool:        """任务执行api"""        result, _ = await self.__execute_interface(interface=interface, taskResult=taskResult)        await InterfaceAPIWriter.write_interface_result(**result)        return _    async def run_interCase(self, interfaceCaseId: int, task: InterfaceTaskResultModel = None):        """        执行接口用例        """        # 查询用例        interfaceCase: InterfaceCase = await InterfaceCaseMapper.get_by_id(ident=interfaceCaseId)        if not interfaceCase:            await self.starter.send(f"未找到用例 {interfaceCaseId}")            return await self.starter.over()        # 查询用例步骤内容        case_steps: InterFaceCases = await InterfaceCaseMapper.query_content(case_id=interfaceCaseId)        await self.starter.send(f"用例 {interfaceCase.title} 执行开始。执行人 {self.starter.username}")        await self.starter.send(f"查询到关联Step x {len(case_steps)} ...")        if not case_steps:            await self.starter.send("无可执行步骤，结束执行")            return await self.starter.over()        # 加载用例专属变量        # 初始化用例结果对象        await self.__init_interface_case_vars(interfaceCase)        log.info(f"__init_interface_case_vars = {self.vars}")        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         task=task,                                                                         starter=self.starter)        log.info(f"init_interface_case_result = {caseResult}")        flag = True        try:            for index, _step_content in enumerate(case_steps, start=1):                await self.starter.send(f"✍️✍️  EXECUTE_STEP {index} ： {_step_content}")                caseResult.progress = round(index / len(case_steps), 2) * 100                log.debug(f"caseResult  progress= {caseResult.progress}")                # 步骤开关旨在 用例调试中使用 任务执行默认开启                if _step_content.enable == 0 and not task:                    await self.starter.send(f"✍️✍️  EXECUTE_STEP {index} ： 调试禁用 跳过执行")                    continue                # 如果 flag 已经是 False 且需要错误停止，则跳过后续步骤                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    await self.starter.send(f"⏭️⏭️  SKIP_STEP {index} ： 遇到错误已停止")                    continue                step_result = True                match _step_content.content_type:                    # 执行单接口                    case CaseStepContentType.STEP_API:                        step_result = await self.__execute_single_api(interface_id=_step_content.target_id,                                                                      case_result=caseResult)                    # 执行接口组                    case CaseStepContentType.STEP_API_GROUP:                        step_result = await self.__execute_group_apis(case_step=_step_content,                                                                      case_result=caseResult)                    # 执行条件皆苦                    case CaseStepContentType.STEP_API_CONDITION:                        step_result = await  self.__execute_condition_apis(case_step=_step_content,                                                                           case_result=caseResult)                    # 执行等待                    case CaseStepContentType.STEP_API_WAIT:                        await self.starter.send(f"⏰⏰  等待 {_step_content.api_wait_time} 秒")                        await asyncio.sleep(_step_content.api_wait_time)                        continue                    # 执行脚本                    case CaseStepContentType.STEP_API_SCRIPT:                        await self.__exec_script(script=_step_content.api_script_text)                        continue                # 一旦 flag 变为 False，就不再变回 True                flag = flag and step_result                # 遇到错停止                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    caseResult.progress = 100                await InterfaceAPIWriter.write_process(caseResult=caseResult)                await self.starter.send(f"✅✅️ FINISH STEP {index} ： {_step_content}")                await self.starter.send(f"\n")            await self.starter.send(f"用例 {interfaceCase.title} 执行结束")            await self.starter.send(f"{'====' * 20}")            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return flag        except Exception as e:            log.error(e)            return False        finally:            await self.vars.clear()            await self.starter.over(caseResult.id)    async def __execute_single_api(self, interface_id: int, case_result: InterfaceCaseResultModel):        """        api类型用例执行        """        interface: Interface = await InterfaceMapper.get_by_id(ident=interface_id)        result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)        await InterfaceAPIWriter.write_interface_result(**result)        if flag:            case_result.success_num += 1        else:            case_result.result = InterfaceAPIResultEnum.ERROR            case_result.fail_num += 1        return flag    async def __execute_condition_apis(self, case_step: InterfaceCaseStepContent,                                       case_result: InterfaceCaseResultModel):        """        逻辑 API执行        :param case_result 用例结果模型        :param case_step  用例步骤        """        condition: InterfaceCondition = await InterfaceConditionMapper.get_by_id(ident=case_step.target_id)        _execCondition = ExecCondition(self.vars)        flag = await _execCondition.invoke(condition, self.starter)        # 逻辑通过 执行子步骤        if flag:            condition_apis = await InterfaceConditionMapper.query_condition_apis_by_content_id(condition.id)            condition_result = await InterfaceConditionResultMapper.init_model(                condition_name=_execCondition.doc,                condition_api_num=len(condition_apis),                interface_case_result_id=case_result.id            )            log.info(f"condition_result  init {condition_result}")            if len(condition_apis) == 0:                return            for index, interface in enumerate(condition_apis, start=1):                await self.starter.send(f"✍️✍️  execute Condition Step {index} : {interface} ")                result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)                await InterfaceAPIWriter.write_interface_result(                    interface_condition_result_id=condition_result.id,                    **result)                # 报错停止                if not flag:                    case_result.result = InterfaceAPIResultEnum.ERROR                    case_result.fail_num += 1                    return False        case_result.success_num += 1        return True    async def __execute_group_apis(self, case_step: InterfaceCaseStepContent,                                   case_result: InterfaceCaseResultModel):        """        组内 API执行        :param case_result 用例结果模型        :param case_step  用例步骤        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=case_step.target_id)        if not interfaces:            return        # 初始化GROUP RESULT        group_result = await InterfaceGroupResultMapper.init_model(            group_name=case_step.content_name,            group_api_num=len(interfaces),            interface_case_result_id=case_result.id        )        log.info(f"group result init {group_result}")        for index, interface in enumerate(interfaces, start=1):            await self.starter.send(f"✍️✍️  EXECUTE GROUP STEP {index} : {interface}")            result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)            # 写API结果 关联Group result            await InterfaceAPIWriter.write_interface_result(interface_group_result_id=group_result.id, **result)            # 报错停止            if not flag:                case_result.result = InterfaceAPIResultEnum.ERROR                case_result.fail_num += 1                return False        case_result.success_num += 1        return True    async def __execute_interface(self,                                  interface: InterfaceModel,                                  caseResult: InterfaceCaseResultModel = None,                                  taskResult: InterfaceTaskResultModel = None                                  ) -> Tuple[Mapping[str, Any], bool]:        """        API 执行        返回执行结果，flag        """        temp_variables = []        asserts_info = None        request_info = None        url = None        # 记录请求时间        t = GenerateTools.getTime(1)        try:            # 0、接口处理请求URL            url = await self.__set_req_url(interface)            # 1、前置变量参数            temp_variables.extend(await self.__exec_before_params(interface.before_params))            # 2、执行前置函数            temp_variables.extend(await self.__exec_script(interface.before_script))            # 3.前置sql            temp_variables.extend(await self.__exec_before_sql(interface))            # 3.1 处理请求 替换变量            request_info = await self.sender.set_req_info(interface)  # request data            url = await self.vars.trans(url)  # url            # 4、执行接口请求            self.response = await self.sender(url=url, method=interface.method, **request_info)            # 5、进行断言            asserts_info = await self.__exec_assert(interface)            # 6、出参提取            temp_variables.extend(await self.__exec_extract(interface))            # 7、执行后置函数            temp_variables.extend(await self.__exec_script(interface.after_script))        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            self.response = f"{str(e)} to {url}"        finally:            request_info['url'] = url            return await  InterfaceAPIWriter.set_interface_result_info(                startTime=t,                starter=self.starter,                request_info=request_info,                interface=interface,                response=self.response,                asserts=asserts_info,                caseResult=caseResult,                taskResult=taskResult,                variables=temp_variables            )    async def __exec_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """处理前置脚本"""        if script:            exe = ExecSafeScript()            _extracted_vars = exe.execute(script)            await self.vars.add_vars(_extracted_vars)            await self.starter.send(f"🫳🫳  脚本 = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeScript                }                for k, v in _extracted_vars.items()            ]            return _vars        return []    async def __exec_before_params(self, before_params: List[Dict[str, Any]] = None):        """处理前置参数"""        if before_params:            values = await self.vars.trans(before_params)            await self.vars.add_vars(values)            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeParams                }                for k, v in self.vars().items()            ]            return _vars        return []    async def __exec_before_sql(self, interface: InterfaceModel):        """        执行前置sql 操作        ## Select            sql:str            - select username from user => [{username:xxx}{username:xxx}][0]            - select username as un  from user => [{un:xxx}{un:xxx}][0]            sql_extracts: [{key:username,jp:$[0].username},{key:username,jp:$[1].username}]            - select username from user => [{username:xxx}{username:xxx}]            ==>  [{username:xx},{username:xx}]        ## Update        """        # 不执行        if not interface.before_sql or not interface.before_db_id:            return []        _db = await DbConfigMapper.get_by_id(interface.before_db_id)        if not _db:            log.warning(f"未找到数据库配置 ID: {interface.before_db_id}")            return []        script = await self.vars.trans(interface.before_sql.strip())        db_script = ExecDBScript(self.starter, script, interface.before_sql_extracts)        res = await db_script.invoke(_db.db_type, **_db.config)        await self.vars.add_vars(res)        await self.starter.send(f"🫳🫳    数据库读取 = {json.dumps(res, ensure_ascii=False)}")        if res:            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL                }                for k, v in res.items()            ]            return _vars        return []    async def __exec_assert(self, interface: InterfaceModel):        """        响应断言        前提：        1、有断言        2、有响应        """        _assert = ExecAsserts(self.response, self.vars())        asserts_info = await _assert(interface.asserts)        await self.starter.send(f"🫳🫳    响应断言 = {json.dumps(asserts_info, ensure_ascii=False)}")        return asserts_info    async def __exec_extract(self, interface: InterfaceModel):        """        变量提取        前提：        1、有断言        2、有响应        3、响应200        """        if interface.extracts and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExecResponseExtract(response=self.response)            _vars = await _extract(interface.extracts)            await self.starter.send(f"🫳🫳    响应参数提取 = {json.dumps(_vars, ensure_ascii=False)}")            await self.vars.add_vars(_vars)            return _vars        return []    async def __init_interface_case_vars(self, interfaceCase: InterfaceCase):        """初始化用例变量"""        try:            interfaceCaseVars: List[InterfaceVariables] = await InterfaceVarsMapper.query_by(case_id=interfaceCase.id)            if interfaceCaseVars:                for iar in interfaceCaseVars:                    _v = await self.vars.trans(iar.value)                    await self.vars.add_vars({iar.key: _v})            if self.vars():                await self.starter.send(f"🫳🫳 初始化用例变量 = {json.dumps(self.vars(), ensure_ascii=False)}")        except Exception as e:            log.error(e)    @staticmethod    async def __set_req_url(interface: Interface) -> str:        """        设置请求url        :param interface:        :return: url        """        try:            if interface.env_id == -1:                return interface.url            else:                env = await EnvMapper.get_by_id(ident=interface.env_id)                return env.url + interface.url        except Exception as e:            log.error(f"设置请求url失败 = {e}")            raise ValueError("请求环境不存在、请检查")