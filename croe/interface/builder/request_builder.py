#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2026/1/21# @Author : cyq# @File : request_builder# @Software: PyCharm# @Desc:import asyncioimport jsonimport osfrom typing import Dict, Any, Tuple, Optionalfrom base64 import b64encodefrom httpx._utils import to_bytesfrom app.mapper.interface import InterfaceGlobalHeaderMapperfrom croe.interface.manager.variable_manager import VariableManagerfrom croe.interface.types import InterfaceAPIfrom enums import InterfaceRequestTBodyTypeEnum, InterfaceRequestMethodEnum, InterfaceAuthTypefrom utils import GenerateTools, logimport mimetypesimport aiofilesclass RequestBuilder:    """请求体"""    def __init__(self, variables: VariableManager):        self.variables = variables    async def set_req_info(self, interface: InterfaceAPI):        """        处理并构建HTTP请求信息        Args:            interface: 接口对象，包含请求方法、头信息、参数等        Returns:            包含完整请求信息的字典，可用于httpx等HTTP客户端        """        # 初始化请求数据字典        _request_data = {'read': interface.response_timeout,                         'connect': interface.connect_timeout,                         'follow_redirects': bool(interface.follow_redirects),                         InterfaceRequestTBodyTypeEnum.HEADERS: await self._prepare_headers(interface)}        # 根据请求方法处理参数或请求体        if interface.method == InterfaceRequestMethodEnum.GET:  # GET            await self._process_get_params(_request_data, interface)        else:            await self._process_request_body(_request_data, interface)        await self._prepare_auth(request_data=_request_data, interface=interface)        # 并行转换请求数据中的变量        await self._transform_request_data(_request_data)        return _request_data    @staticmethod    async def _prepare_auth(request_data: Dict[str, Any], interface: InterfaceAPI):        """        处理auth        kv auth {key:        """        match interface.auth_type:            # KV auth            case InterfaceAuthType.KV_Auth:                _auth = interface.auth                target = _auth.pop("target")                if target == "query":                    request_data[InterfaceRequestTBodyTypeEnum.PARAMS].update(                        GenerateTools.list2dict(_auth)                    )                elif target == "header":                    request_data[InterfaceRequestTBodyTypeEnum.HEADERS].update(                        GenerateTools.list2dict(_auth)                    )            # basic auth            case InterfaceAuthType.BASIC_Auth:                userpass = b":".join(                    (to_bytes(interface.auth.get("username", None)), to_bytes(interface.auth.get("password", None))))                token = b64encode(userpass).decode()                auth = {"Authorization": f"Basic {token}"}                request_data[InterfaceRequestTBodyTypeEnum.HEADERS].update(                    auth                )            # bearer auth            case InterfaceAuthType.BEARER_Auth:                auth = {"Authorization": f"Bearer {interface.auth.get('token')}"}                request_data[InterfaceRequestTBodyTypeEnum.HEADERS].update(                    auth                )    @staticmethod    async def _prepare_headers(interface: InterfaceAPI) -> Dict[str, str]:        """准备请求头（合并全局和接口特定头）"""        headers = {}        # 添加全局头        global_headers = await InterfaceGlobalHeaderMapper.query_all()        for header in global_headers:            headers.update(header.map)        # 添加接口特定头        if interface.headers:            headers.update(GenerateTools.list2dict(interface.headers))        return headers    @staticmethod    async def _process_get_params(_request_data: Dict[str, Any], interface: InterfaceAPI) -> None:        """处理GET请求参数"""        if interface.params:            _request_data[InterfaceRequestTBodyTypeEnum.PARAMS] = GenerateTools.list2dict(interface.params)    async def _process_request_body(self, request_data: Dict[str, Any], interface: InterfaceAPI) -> None:        """处理非GET请求的请求体"""        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null:            return        body_data, content_type = await self._filter_request_body(interface)        if content_type:            request_data[InterfaceRequestTBodyTypeEnum.HEADERS]["Content-Type"] = content_type        if body_data:            request_data.update(**body_data)    async def _filter_request_body(self, interface: InterfaceAPI) -> Tuple[Dict[str, Any] | None, str | None]:        """根据接口请求体类型处理请求体数据        Args:            interface: 接口对象，包含请求体相关数据        Returns:            Tuple[处理后的请求体字典, Content-Type字符串]            如果不需要请求体则返回 (None, None)        """        log.info(f"request body = {interface.body}")        log.info(f"request body_type = {interface.body_type}")        match interface.body_type:            case InterfaceRequestTBodyTypeEnum.Raw:                return await self._prepare_raw_body(interface)            case InterfaceRequestTBodyTypeEnum.UrlEncoded:                return await self._prepare_form_urlencoded(interface)            case InterfaceRequestTBodyTypeEnum.Data:                return await self._prepare_form_data(interface)            case _:                log.warning(f"Unsupported body type: {interface.body_type}")                return None, None    async def _transform_request_data(self, request_data: Dict[str, Any]) -> None:        """并行转换请求数据中的变量"""        # transform_tasks = [        #     self.vr.trans(value)        #     for value in request_data.values()        #     if value is not None        # ]        # 筛选需要转换的键值对        items_to_transform = {            key: value for key, value in request_data.items()            if value is not None        }        if not items_to_transform:            return        # 并行转换        async with asyncio.TaskGroup() as tg:            tasks = {                tg.create_task(self.variables.trans(value)): key                for key, value in items_to_transform.items()            }        # 更新数据        for task, key in tasks.items():            transformed_value = task.result()            if transformed_value is not None:                request_data[key] = transformed_value        # transformed_values = [task.result() for task in tasks]        # # transformed_values = await asyncio.gather(*transform_tasks)        #        # for key, value in zip(request_data.keys(), transformed_values):        #     if value is not None:        #         request_data[key] = value    @staticmethod    async def _prepare_raw_body(interface: InterfaceAPI) -> Tuple[Dict[str, Any], str]:        """准备原始请求体（JSON/Text）"""        if interface.raw_type == "json":            return (                {InterfaceRequestTBodyTypeEnum.JSON: interface.body},                "application/json"            )        else:  # text            return (                {InterfaceRequestTBodyTypeEnum.Content: json.dumps(interface.body)},                "text/plain"            )    @staticmethod    async def _prepare_form_urlencoded(interface: InterfaceAPI) -> Tuple[Dict[str, Any], str]:        """准备URL编码表单数据"""        form_data = GenerateTools.list2dict(interface.data)        return (            {InterfaceRequestTBodyTypeEnum.FORM_DATA: form_data},            "application/x-www-form-urlencoded"        )    async def _prepare_form_data(self, interface: InterfaceAPI) -> Tuple[Dict[str, Any], Optional[str]]:        """准备多部分表单数据（支持文件上传）"""        files = {}        data = {}        form_data = GenerateTools.list2dict(interface.data)        for key, value in form_data.items():            # 附件类型            if str(value).startswith(str(interface.uid)):                file_info = await self._prepare_file_upload(key, value)                if file_info:                    files[key] = file_info            else:                data[key] = value        return (            {InterfaceRequestTBodyTypeEnum.FORM_FILES: files,             InterfaceRequestTBodyTypeEnum.FORM_DATA: data},            None  # Content-Type将由httpx自动设置        )    @staticmethod    async def _prepare_file_upload(key: str, value: Any) -> Optional[Tuple]:        """准备文件上传数据"""        from utils.fileManager import API_DATA        files = {}        filepath = os.path.join(API_DATA, value)        log.debug(f"filepath = {filepath}")        try:            # 确保文件存在并可读            if not os.path.exists(filepath):                log.error(f"文件不存在: {filepath}")                return            if not os.access(filepath, os.R_OK):                log.error(f"文件不可读: {filepath}")                return            # 获取文件的 MIME 类型            mime_type, _ = mimetypes.guess_type(str(filepath))            mime_type = mime_type or 'application/octet-stream'  # 默认类型            fileName = os.path.basename(filepath).split("_")[-1]            # 使用 aiofiles 读取文件内容            async with aiofiles.open(filepath, 'rb') as f:                file_content = await f.read()            if file_content:                files[key] = (fileName, file_content, mime_type)                log.debug(f"文件 {fileName} 已添加到上传列表，MIME类型 = {mime_type}")            else:                log.error(f"无法读取文件 {filepath}")                return None        except Exception as e:            log.exception(f"处理文件 {filepath} 时出错: {str(e)}")            return None