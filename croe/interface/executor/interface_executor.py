#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2026/1/21# @Author : cyq# @File : interface_executor# @Software: PyCharm# @Desc:import copyimport jsonfrom typing import Union, Tuple, Any, Dict, List, TypeVar, Mapping, Optionalimport httpxfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom common.httpxClient import HttpxClientfrom croe.interface.builder.request_builder import RequestBuilderfrom croe.interface.builder.url_builder import UrlBuilderfrom croe.interface.manager.assert_manager import AssertManagerfrom croe.interface.manager.extract_manager import ExtractManagerfrom croe.interface.manager.script_manager import ScriptManagerfrom croe.interface.manager.variable_manager import VariableManagerfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnumfrom croe.interface.starter import APIStarterfrom interface.types import *from play.starter import UIStarterfrom utils import log, GenerateToolsfrom utils.execDBScript import ExecDBScriptBeforeParams = TypeVar("BeforeParams", bound=Union[List[Dict[str, Any]]])class InterfaceExecutor:    """æ¥å£æ‰§è¡Œå™¨"""    def __init__(self, starter: Union[UIStarter, APIStarter], variable_manager: VariableManager):        self.variable_manager = variable_manager        self.starter = starter        self.http = HttpxClient(logger=self.starter.send)    async def execute(self,                      interface: "InterfaceAPI",                      env: "Env" = None,                      case_result: Optional["InterfaceCaseResult"] = None,                      task_result: Optional["InterfaceTaskResult"] = None,                      temp_var: "VARS" = None) -> Tuple['InterfaceResultInfo', bool]:        """        æ‰§è¡Œæ¥å£ç”¨ä¾‹        :param interface: æ¥å£ç”¨ä¾‹        :param env: ç¯å¢ƒå˜é‡        :param case_result: ç”¨ä¾‹ç»“æœ        :param task_result: ä»»åŠ¡ç»“æœ        :param temp_var: ä¸´æ—¶å˜é‡        :return: æ¥å£ç»“æœä¿¡æ¯, æ˜¯å¦æ‰§è¡ŒæˆåŠŸ        """        temp_variables = await get_temp_variables(temp_var)        start_time = GenerateTools.getTime(1)        await self.starter.send(f"âœï¸âœï¸  EXECUTE API : {interface} ")        resolved_url = ""        asserts_info = None        request_info = None        response = None        try:            # æ„å»ºurl            origin_url = await UrlBuilder.build(interface=interface, env=env)            # æ‰§è¡Œå‰å¤„ç†            temp_variables.extend(await self._before_execute(interface))            # æ„å»ºè¯·æ±‚ä¿¡æ¯            builder = RequestBuilder(self.variable_manager)            request_info = await builder.set_req_info(interface)            # æ›¿æ¢å˜é‡åˆ°url            resolved_url = await self.variable_manager.trans(origin_url)            # æ‰§è¡Œè¯·æ±‚            response = await self.http(url=resolved_url, method=interface.method, **request_info)            # æå–å˜é‡            temp_variables.extend(await self.__execute_extract(response=response, interface=interface))            # æ‰§è¡Œæ–­è¨€            asserts_info = await self.__execute_assert(response=response, interface=interface)        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            response = f"{str(e)} to {resolved_url}"        finally:            request_info['url'] = resolved_url            return await set_interface_result_info(                startTime=start_time,                starter=self.starter,                request_info=request_info,                interface=interface,                response=response,                asserts=asserts_info,                case_result=case_result,                task_result=task_result,                variables=temp_variables            )    async def _before_execute(self, interface: "InterfaceAPI") -> List:        """        æ‰§è¡Œå‰å¤„ç†        :param interface: æ¥å£ç”¨ä¾‹        :return: ä¸´æ—¶å˜é‡        """        temp_variables = []        temp_variables.extend(await self.__execute_before_params(interface.before_params))        temp_variables.extend(await self.__execute_before_script(interface.before_script))        temp_variables.extend(await self.__execute_before_sql(interface))        return temp_variables    async def __execute_before_params(self, before_params: "BeforeParams" = None) -> List:        """        æ‰§è¡Œå‰å‚æ•°å¤„ç†        :param before_params: æ‰§è¡Œå‰å‚æ•°        :return: None        """        if not before_params:            return []        values = await self.variable_manager.trans(before_params)        log.info(f"æ‰§è¡Œå‰å‚æ•°å¤„ç†: {values}")        if values:            await self.variable_manager.add_vars(values)            return [                {                    **item,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeParams                }                for item in values            ]    async def __execute_before_sql(self, interface: "InterfaceAPI") -> List:        """        æ‰§è¡Œå‰sqlå¤„ç†        :param interface: æ¥å£ç”¨ä¾‹        :return: None        """        if not interface.before_sql or not interface.before_db_id:            return []        _db = await DbConfigMapper.get_by_id(interface.before_db_id)        if not _db:            await self.starter.send(f"æ•°æ®åº“é…ç½®ä¸å­˜åœ¨ï¼Œdb_id = {interface.before_db_id}")            return []        _db_script = await self.variable_manager.trans(interface.before_sql.strip())        log.info(f"æ‰§è¡Œå‰sqlå¤„ç†: {_db_script}")        db_script = ExecDBScript(self.starter, _db_script, interface.before_sql_extracts)        result = await db_script.invoke(_db.db_type, **_db.config)        await self.variable_manager.add_vars(result)        await self.starter.send(f"ğŸ«³ğŸ«³    æ•°æ®åº“è¯»å– = {result}")        if result:            return [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL                }                for k, v in result.items()            ]        return []    async def __execute_before_script(self, script: str):        """        æ‰§è¡Œå‰è„šæœ¬å¤„ç†        :param script: æ‰§è¡Œå‰è„šæœ¬        :return: None        """        if script:            script_manger = ScriptManager()            _extracted_vars = script_manger.execute(script)            await self.variable_manager.add_vars(_extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³  è„šæœ¬ = {json.dumps(_extracted_vars, ensure_ascii=False)}")            return [{                InterfaceExtractTargetVariablesEnum.KEY: k,                InterfaceExtractTargetVariablesEnum.VALUE: v,                InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeScript            } for k, v in _extracted_vars.items()]        return []    async def __execute_assert(self, response: "httpx.Response", interface: "InterfaceAPI"):        """        å“åº”æ–­è¨€        å‰æï¼š        1ã€æœ‰æ–­è¨€        2ã€æœ‰å“åº”        """        _assert = AssertManager(response, self.variable_manager.variables)        asserts_info = await _assert(interface.asserts)        if asserts_info:            await self.starter.send(f"ğŸ«³ğŸ«³  å“åº”æ–­è¨€ = {json.dumps(asserts_info, ensure_ascii=False)}")        else:            await self.starter.send(f"ğŸ«³ğŸ«³  æœªé…ç½® å“åº”æ–­è¨€ âš ï¸âš ï¸")        return asserts_info    async def __execute_extract(self, response: "httpx.Response", interface: "InterfaceAPI"):        """        å˜é‡æå–        å‰æï¼š        1ã€æœ‰æ–­è¨€        2ã€æœ‰å“åº”        3ã€å“åº”200        """        if interface.extracts and response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExtractManager(response=response)            _interface_extract = copy.deepcopy(interface.extracts)  #            _vars = await _extract(_interface_extract)            await self.starter.send(f"ğŸ«³ğŸ«³  å“åº”å‚æ•°æå– = {[{v.get('key'): v.get('value')} for v in _vars]}")            await self.variable_manager.add_vars(_vars)            return _vars        return []async def get_temp_variables(temp_vars: VARS) -> List:    """    å¤„ç†ä¸´æ—¶å˜é‡    :param temp_vars: ä¸´æ—¶å˜é‡    :return: ä¸´æ—¶å˜é‡åˆ—è¡¨    """    _temp_variables = []    if temp_vars:        if isinstance(temp_vars, list):            _temp_variables.extend(temp_vars)        else:            _temp_variables.append(temp_vars)    return _temp_variablesasync def set_interface_result_info(        startTime: str,        starter: "APIStarter",        interface: "InterfaceAPI",        request_info: Optional[Dict[str, Any]] = None,        response: Union["httpx.Response" ,str] = None,        asserts: List[Mapping[str, Any]] = None,        case_result: Optional["InterfaceCaseResult"] = None,        variables: List[Mapping[str, Any]] = None,        task_result: Optional["InterfaceTaskResult"] = None) -> Tuple[InterfaceResultInfo, bool]:    """    è®¾ç½®æ¥å£ç»“æœä¿¡æ¯    :param startTime: è¯·æ±‚æ—¶é—´è®°å½•    :param starter: æ‰§è¡Œäºº    :param interface: æ¥å£å®ä½“    :param request_info: æ¥å£è¯·æ±‚ä½“    :param response: å“åº”ç»“æœå¯¹è±¡    :param asserts: æ–­è¨€ä¿¡æ¯    :param case_result: ç”¨ä¾‹ç»“æœå®ä¾‹    :param variables: å˜é‡    :param task_result: ä»»åŠ¡ç»“æœå®ä¾‹    :return: ç»“æœä¿¡æ¯å’Œæ‰§è¡ŒçŠ¶æ€    """    # æ„å»ºåŸºç¡€ä¿¡æ¯    _interfaceBaseInfo = {        'startTime': startTime,        'interfaceID': interface.id,        'interfaceName': interface.name,        'interfaceUid': interface.uid,        'interfaceDesc': interface.desc,        'starterId': starter.userId,        'starterName': starter.username,        'interfaceProjectId': interface.project_id,        'interfaceModuleId': interface.module_id,        'interfaceEnvId': interface.env_id,        'request_info': request_info    }    # æ·»åŠ å…³è”ID    if task_result:        _interfaceBaseInfo['interface_task_result_Id'] = task_result.id    if case_result:        _interfaceBaseInfo['interface_case_result_Id'] = case_result.id    # åˆå§‹åŒ–å“åº”ä¿¡æ¯    _response = {        'extracts': variables or [],        'asserts': asserts or [],        'result': InterfaceAPIResultEnum.SUCCESS,        'request_method': interface.method.upper()    }    # å¤„ç†å“åº”ç»“æœ    flag = True    if isinstance(response, str):        # å­—ç¬¦ä¸²å“åº”è¡¨ç¤ºé”™è¯¯        _response.update({            'response_status': 500,            'response_txt': response,            'result': InterfaceAPIResultEnum.ERROR        })        flag = False    elif isinstance(response, httpx.Response):        # Responseå¯¹è±¡å¤„ç†        is_success = response.status_code == 200        _response.update({            'result': InterfaceAPIResultEnum.SUCCESS if is_success else InterfaceAPIResultEnum.ERROR,            'response_status': response.status_code,            'response_txt': response.text,            'response_head': dict(response.headers),            'request_head': dict(response.request.headers),            'useTime': round(response.elapsed.total_seconds() * 1000, 2)  # è½¬æˆms        })        flag = is_success    # å¤„ç†æ–­è¨€ç»“æœ    if asserts:        has_failed_assert = any(assert_item.get('result') is False for assert_item in asserts)        if has_failed_assert:            flag = False            _response['result'] = InterfaceAPIResultEnum.ERROR    return {**_interfaceBaseInfo, **_response}, flag