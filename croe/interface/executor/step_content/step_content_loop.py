#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2026/1/21# @Author : cyq# @File : loop# @Software: PyCharm# @Desc:import asyncioimport jsonfrom turtledemo.penrose import startfrom typing import Listfrom app.mapper.interface.interfaceCaseMapper import InterfaceLoopMapperfrom croe.interface.executor.context import CaseStepContextfrom croe.interface.executor.step_content.base import StepBaseStrategyfrom croe.interface.manager.condition_manager import ConditionManagerfrom croe.interface.writer import init_case_step_loop_result, write_case_content_result, write_interface_resultfrom croe.interface.types import Loop, InterfaceAPI, Env, InterfaceContentResultfrom enums import InterfaceAPIResultEnum, InterfaceExtractTargetVariablesEnumfrom enums.CaseEnum import LoopTypeEnumfrom utils import GenerateTools, logfrom utils.assertsUtil import MyAssertsclass APILoopContentStrategy(StepBaseStrategy):    """        循环步骤执行策略    """    async def execute(self, step_context: CaseStepContext) -> bool:        """        循环执行步骤        """        loop = await InterfaceLoopMapper.get_by_id(ident=step_context.content.target_id)        loop_steps = await InterfaceLoopMapper.query_loop_apis_by_content_id(loop_id=step_context.content.target_id)        start_time = GenerateTools.getTime(1)        loop_content_result = await init_case_step_loop_result(            step_index=step_context.index,            interface_case_result_id=step_context.case_result_id,            step_content=step_context.content,            starter=step_context.starter,            start_time=start_time,            interface_task_result_id=step_context.task_result_id,        )        match loop.loop_type:            case LoopTypeEnum.LoopTimes:                return await self.__execute_loop_times(                    step_context=step_context,                    loop=loop,                    api_steps=loop_steps,                    content_result=loop_content_result                )            case LoopTypeEnum.LoopItems:                return await self.__execute_loop_items(                    step_context=step_context,                    loop=loop,                    api_steps=loop_steps,                    content_result=loop_content_result                )            case LoopTypeEnum.LoopCondition:                return await self.__execute_loop_condition(                    step_context=step_context,                    loop=loop,                    api_steps=loop_steps,                    content_result=loop_content_result                )    async def __execute_loop_times(self, step_context: CaseStepContext,                                   loop: Loop,                                   api_steps: List["InterfaceAPI"],                                   content_result: InterfaceContentResult):        """        times 循环        全部执行完  不论对错        全对 content result = true        case success +1        :param loop:        :param api_steps:        :return:        """        ALL_SUCCESS = True        case_result = step_context.execution_context.case_result        for i in range(1, loop.loop_times + 1):            for index, interface in enumerate(api_steps, start=1):                await step_context.starter.send(                    f"✍️✍️  {'-' * 20} 次数循环步骤 次数{i}   {interface.name} {'-' * 20}"                )                # 执行单个接口                interface_result, success = await self.interface_executor.execute(                    interface=interface,                    env=step_context.execution_context.env,                    case_result=case_result                )                # 记录接口执行结果                await write_interface_result(                    interface_loop_result_id=content_result.id,                    **interface_result                )                if success is False:                    ALL_SUCCESS = False                if loop.loop_interval > 0:                    await asyncio.sleep(loop.loop_interval)        content_result.content_result = ALL_SUCCESS        if ALL_SUCCESS:            case_result.success_num += 1        else:            case_result.fail_num += 1            case_result.result = InterfaceAPIResultEnum.ERROR        await write_case_content_result(content_result)        return ALL_SUCCESS    async def __execute_loop_items(self, step_context: CaseStepContext,                                   loop: Loop,                                   api_steps: List["InterfaceAPI"],                                   content_result: InterfaceContentResult):        """        items 遍历        :param loop:            a = "1,2,3,4"            b = [1,2,3,4]            c = "{{a}},b,c,e"        :param api_steps:        :return:        """        try:            items = json.loads(loop.loop_items)        except json.JSONDecodeError:            items = [item.strip() for item in loop.loop_items.split(',') if item.strip()]        ALL_SUCCESS = True        case_result = step_context.execution_context.case_result        if items:            total_apis = len(api_steps)            for item in items:                for index, interface in enumerate(api_steps, start=1):                    ItemKey = loop.loop_item_key                    await step_context.starter.send(                        f"✍️✍️  {'-' * 20} 执行数组循环步骤 [{ItemKey}:{item}] {index}/{total_apis}: "                        f"{interface.name} {'-' * 20}"                    )                    interface_result, success = await self.interface_executor.execute(                        interface=interface,                        env=step_context.execution_context.env,                        case_result=case_result,                        temp_var={InterfaceExtractTargetVariablesEnum.KEY: ItemKey,                                  InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.LOOP,                                  InterfaceExtractTargetVariablesEnum.VALUE: item}                    )                    # 记录接口执行结果                    await write_interface_result(                        interface_loop_result_id=content_result.id,                        **interface_result                    )                    if success is False:                        ALL_SUCCESS = False                    if loop.loop_interval > 0:                        await asyncio.sleep(loop.loop_interval)        if ALL_SUCCESS:            case_result.success_num += 1        else:            case_result.failure_num += 1            case_result.result = InterfaceAPIResultEnum.ERROR        content_result.content_result = ALL_SUCCESS        await write_case_content_result(content_result)        return ALL_SUCCESS    async def __execute_loop_condition(self,                                       step_context: CaseStepContext,                                       loop: Loop,                                       api_steps: List["InterfaceAPI"],                                       content_result: InterfaceContentResult):        """        条件 循环        :param loop:            key: str  'abc' '{{name}}'            value: str 1            operator: int        :param api_steps:        :return:        """        # 执行条件判断        _execCondition = ConditionManager(step_context.variable_manager.vars)        n = 0        LOOP_SUCCESS = True        case_result = step_context.execution_context.case_result        while True:            n += 1            for index, interface in enumerate(api_steps, start=1):                await step_context.starter.send(                    f"✍️✍️  {'-' * 20} 执行循环步骤  {n} times: "                    f"{interface.name} {'-' * 20}"                )                # 执行单个接口                interface_result, success = await self.interface_executor.execute(                    interface=interface,                    env=step_context.execution_context.env,                    case_result=case_result                )                if success is False:                    LOOP_SUCCESS = False                # 记录接口执行结果                await write_interface_result(                    interface_loop_result_id=content_result.id,                    **interface_result                )                if loop.loop_interval > 0:                    LOOP_SUCCESS = False                    await asyncio.sleep(loop.loop_interval)            key = await step_context.variable_manager.trans(loop.key)            value = await step_context.variable_manager.trans(loop.value)            log.info(f"__loop_condition  key = {key}")            log.info(f"__loop_condition  value = {value}")            log.info(f"__loop_condition  operate = {loop.operate}")            if n > loop.max_loop:                await step_context.starter.send(                    f"✍️✍️  执行循环步骤  {n} times: 循环次数超过最大限制"                )                break            try:                MyAsserts.option(                    assertOpt=loop.operate,                    expect=key,                    actual=value                )                LOOP_SUCCESS = True                break            except AssertionError:                await step_context.starter.send(                    f"✍️✍️  执行循环步骤  {n} times: 断言失败 key = {key} type = {type(key)}  value = {value} type = {type(value)}"                )                continue        if LOOP_SUCCESS:            case_result.success_num += 1        else:            case_result.fail_num += 1            case_result.result = InterfaceAPIResultEnum.ERROR        content_result.content_result = LOOP_SUCCESS        await write_case_content_result(content_result)        return LOOP_SUCCESS