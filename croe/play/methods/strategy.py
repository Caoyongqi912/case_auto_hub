#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2026/1/29# @Author : cyq# @File : wait# @Software: PyCharm# @Desc:# !/usr/bin/env python# -*- coding:utf-8 -*-import asynciofrom dataclasses import dataclassfrom typing import Optional, Callable, Anyfrom playwright.async_api import Page, Locatorfrom utils import logfrom config import Config@dataclassclass WaitConfig:    """    等待策略配置类    管理各种等待操作的超时时间和轮询间隔，包括元素等待、导航等待、    默认等待等。    """    default_timeout: int = 10000    navigation_timeout: int = 30000    element_timeout: int = 5000    polling_interval: int = 100    retry_interval: int = 1000    @classmethod    def fromconfig(cls) -> "WaitConfig":        """        从全局配置创建等待配置对象        Returns:            WaitConfig: 等待配置实例        """        return cls()class WaitStrategy:    """    等待策略类    提供多种等待方法，包括元素等待、导航等待、函数等待、选择器等待等，    支持自定义超时时间和轮询间隔。    """    def __init__(self):        """        初始化等待策略        """        self.config = WaitConfig.fromconfig()    async def wait_for_element(            self,            locator: Locator,            state: str = "visible",            timeout: Optional[int] = None    ) -> None:        """        等待元素达到指定状态        等待元素出现、消失、附加到DOM等状态。        Args:            locator: 元素定位器对象            state: 等待的状态，可选值：'attached'、'detached'、'visible'、'hidden'            timeout: 超时时间（毫秒），默认使用配置中的元素超时时间        Raises:            TimeoutError: 当等待超时时抛出        """        timeout = timeout or self.config.element_timeout        try:            await locator.wait_for(state=state, timeout=timeout)        except Exception as e:            log.error(f"Wait for element failed: {locator}, state: {state}, error: {e}")            raise TimeoutError(f"Element wait timeout: {state}", details=str(e))    async def wait_for_navigation(            self,            page: Page,            timeout: Optional[int] = None,            wait_until: str = "load"    ) -> None:        """        等待页面导航完成        等待页面加载到指定状态，如'domcontentloaded'、'load'、'networkidle'等。        Args:            page: 页面对象            timeout: 超时时间（毫秒），默认使用配置中的导航超时时间            wait_until: 等待的加载状态，默认为'load'        Raises:            TimeoutError: 当等待超时时抛出        """        timeout = timeout or self.config.navigation_timeout        try:            await page.wait_for_load_state(wait_until, timeout=timeout)        except Exception as e:            log.error(f"Wait for navigation failed: {e}")            raise TimeoutError(f"Navigation wait timeout", details=str(e))    async def wait_for_timeout(self, timeout: int) -> None:        """        等待指定时间        简单的延迟等待，不依赖任何条件。        Args:            timeout: 等待时间（毫秒）        """        await asyncio.sleep(timeout / 1000)    async def wait_for_function(            self,            page: Page,            script: str,            timeout: Optional[int] = None,            polling: Optional[int] = None,            **kwargs    ) -> Any:        """        等待JavaScript函数返回真值        在页面上下文中执行JavaScript函数，直到函数返回真值或超时。        Args:            page: 页面对象            script: 要执行的JavaScript代码            timeout: 超时时间（毫秒），默认使用配置中的默认超时时间            polling: 轮询间隔（毫秒），默认使用配置中的轮询间隔            **kwargs: 传递给函数的额外参数        Returns:            Any: JavaScript函数的返回值        Raises:            TimeoutError: 当等待超时时抛出        """        timeout = timeout or self.config.default_timeout        polling = polling or self.config.polling_interval        try:            return await page.wait_for_function(                script,                timeout=timeout,                polling=polling,                **kwargs            )        except Exception as e:            log.error(f"Wait for function failed: {script}, error: {e}")            raise TimeoutError(f"Function wait timeout", details=str(e))    async def wait_for_selector(            self,            page: Page,            selector: str,            state: str = "visible",            timeout: Optional[int] = None    ) -> None:        """        等待选择器匹配的元素达到指定状态        通过CSS选择器等待元素出现、消失等状态。        Args:            page: 页面对象            selector: CSS选择器            state: 等待的状态，默认为 'visible'            timeout: 超时时间（毫秒），默认使用配置中的元素超时时间        Raises:            TimeoutError: 当等待超时时抛出        """        timeout = timeout or self.config.element_timeout        try:            await page.wait_for_selector(selector, state=state, timeout=timeout)        except Exception as e:            log.error(f"Wait for selector failed: {selector}, state: {state}, error: {e}")            raise TimeoutError(f"Selector wait timeout: {selector}", details=str(e))    async def wait_until(            self,            condition: Callable[[], bool],            timeout: Optional[int] = None,            polling_interval: Optional[int] = None    ) -> None:        """        等待条件满足        轮询检查条件是否满足，直到条件为真或超时。        Args:            condition: 条件函数，返回布尔值            timeout: 超时时间（毫秒），默认使用配置中的默认超时时间            polling_interval: 轮询间隔（毫秒），默认使用配置中的轮询间隔        Raises:            TimeoutError: 当等待超时时抛出        """        timeout = timeout or self.config.default_timeout        polling_interval = polling_interval or self.config.polling_interval        start_time = asyncio.get_event_loop().time()        while True:            if condition():                return            elapsed = (asyncio.get_event_loop().time() - start_time) * 1000            if elapsed >= timeout:                raise TimeoutError("Condition wait timeout")            await asyncio.sleep(polling_interval / 1000)    async def smart_wait(            self,            page: Page,            locator: Optional[Locator] = None,            selector: Optional[str] = None,            state: str = "visible",            timeout: Optional[int] = None    ) -> None:        """        智能等待        根据提供的参数自动选择合适的等待方式：        - 如果提供了locator，则等待元素        - 如果提供了selector，则等待选择器        - 否则等待导航        Args:            page: 页面对象            locator: 可选的元素定位器            selector: 可选的CSS选择器            state: 等待的状态，默认为'visible'            timeout: 超时时间（毫秒）        """        if locator:            await self.wait_for_element(locator, state, timeout)        elif selector:            await self.wait_for_selector(page, selector, state, timeout)        else:            await self.wait_for_navigation(page, timeout)class SmartWaiter:    """    智能等待器    提供高级等待方法，如等待页面就绪、可交互、稳定等。    """    def __init__(self):        """        初始化智能等待器        """        self._strategy = WaitStrategy()    async def wait_for_ready(self, page: Page) -> None:        """        等待页面DOM内容加载完成        等待页面的DOMContentLoaded事件触发，此时DOM结构已加载完成。        Args:            page: 页面对象        """        await self._strategy.wait_for_navigation(page, wait_until="domcontentloaded")    async def wait_for_interactive(self, page: Page) -> None:        """        等待页面可交互        等待页面的load事件触发，此时页面已完全加载并可交互。        Args:            page: 页面对象        """        await self._strategy.wait_for_navigation(page, wait_until="load")    async def wait_for_stable(self, page: Page, stable_duration: int = 500) -> None:        """        等待页面稳定        简单地等待一段时间，确保页面状态稳定。        Args:            page: 页面对象            stable_duration: 稳定等待时间（毫秒），默认为500毫秒        """        await asyncio.sleep(stable_duration / 1000)