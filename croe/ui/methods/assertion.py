#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2026/1/29# @Author : cyq# @File : assert_methods# @Software: PyCharm# @Desc:import refrom typing import Any, Dictfrom playwright.async_api import expectfrom app.model.playUI import PlayStepfrom utils import GenerateToolsfrom .base import BaseMethodsfrom ..locator.locator import get_locatorfrom ..wait.strategy import WaitStrategyfrom ..exceptions import AssertionFailedErrorfrom .context import StepContextfrom ..result.writer import PlayResultWriterclass AssertTextMethod(BaseMethods):    """    文本断言    """    handler_name = "expect.play_to_have_text"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step, opt="=",                                      expect_value=context.step.fill_value)        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="visible")        expected_text = await context.variable_manager.trans(context.step.fill_value)        actual_text = await locator.inner_text()        if actual_text: actual_text.strip()        assert_info["assert_actual"] = actual_text        assert_info["assert_result"] = True        try:            await expect(locator).to_have_text(expected_text,                                               use_inner_text=True)            await context.starter.send(f"文本断言 ✅ :to_have_text {actual_text}")        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"Text assertion failed",                details=f"Expected: {expected_text}, Actual: {actual_text}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])class AssertValueMethod(BaseMethods):    handler_name = "expect.play_to_have_value"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step,                                      opt="=",                                      expect_value=context.step.fill_value)        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="visible")        expected_text = await context.variable_manager.trans(context.step.fill_value)        actual_text = await locator.input_value()        if actual_text: actual_text.strip()        assert_info["assert_actual"] = actual_text        assert_info["assert_result"] = True        try:            await expect(locator).to_have_value(expected_text)            await context.starter.send(f"文本断言 ✅ :to_have_value {actual_text}")        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"value assertion failed",                details=f"Expected: {expected_text}, Actual: {actual_text}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])class AssertVisibleMethod(BaseMethods):    handler_name = "expect.play_to_be_visible"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step,                                      opt="=")        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="visible")        try:            await expect(locator).to_be_visible()            assert_info["assert_actual"] = True            assert_info["assert_result"] = True        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"to_be_visible failed",                details=f"Expected: {e}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])class AssertEnabledMethod(BaseMethods):    """    元素启用    """    handler_name = "expect.play_assert_enabled"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step,opt="=")        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="attached")        try:            await expect(locator).to_be_enabled()            assert_info["assert_actual"] = True            assert_info["assert_result"] = True            await context.starter.send(f"启用状态断言 ✅ : {context.selector}")        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"to_be_visible failed",                details=f"Expected: {e}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])class AssertDisabledMethod(BaseMethods):    """    元素启用    """    handler_name = "expect.play_assert_disabled"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step,opt="=")        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="attached")        try:            await expect(locator).to_be_disabled()            await context.starter.send(f"禁用状态断言 ✅ : {context.selector}")            assert_info["assert_actual"] = True            assert_info["assert_result"] = True        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"to_be_disabled failed",                details=f"Expected: {e}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])class AssertCheckedMethod(BaseMethods):    handler_name = "expect.play_assert_checked"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step,opt="=")        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="visible")        try:            await expect(locator).to_be_checked()            await context.starter.send(f"勾选状态断言 ✅ : {context.selector}")            assert_info["assert_actual"] = True            assert_info["assert_result"] = True        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"to_be_checked failed",                details=f"Expected: {e}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])class AssertUncheckedMethod(BaseMethods):    handler_name = "expect.play_assert_unchecked"    async def execute(self, context: StepContext) -> None:        assert_info = set_assert_info(play_step=context.step,opt="=")        locator = await get_locator(context.page, context)        wait_strategy = WaitStrategy()        await wait_strategy.wait_for_element(locator, state="visible")        try:            await expect(locator).not_to_be_checked()            await context.starter.send(f"未勾选状态断言 ✅ : {context.selector}")            assert_info["assert_actual"] = True            assert_info["assert_result"] = True        except AssertionError as e:            assert_info["assert_actual"] = await get_error_value(e)            raise AssertionFailedError(                f"not_to_be_checked failed",                details=f"Expected: {e}"            )        finally:            await PlayResultWriter.write_assert_info(context.case_result, [assert_info])def set_assert_info(play_step: PlayStep, opt: str, expect_value: Any=None) -> Dict[str, Any]:    return {        "id": GenerateTools.getTime(3),        "desc": play_step.description,        "type": "UI",        "assert_name": play_step.name,        "assert_opt": opt,        "assert_script": play_step.method,        "assert_expect": expect_value,        "assert_actual": None,        "assert_result": False    }async def get_error_value(e: AssertionError):    err = str(e)    if "Actual value:" in err:        # 正则表达式匹配 Actual value 和 Call log 之间的内容        pattern = r"Actual value:\s*(.*?)\s*Call log:"        match = re.search(pattern, err, re.DOTALL)        if match:            actual_value = match.group(1).strip()            return actual_value        else:            return ""    return ""