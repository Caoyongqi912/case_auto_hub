#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/12/1# @Author : cyq# @File : trigger# @Software: PyCharm# @Desc:from dataclasses import dataclass, fieldfrom datetime import datetimefrom typing import Optionalfrom apscheduler.triggers.cron import CronTriggerfrom apscheduler.triggers.interval import IntervalTriggerfrom apscheduler.triggers.date import DateTriggerfrom enums import TriggerType@dataclass(kw_only=True)class Trigger:    trigger_type: str    run_date: Optional[str] = None    cron: Optional[str] = None    hours: Optional[int] = None    def __post_init__(self):        self._trigger = self._create_trigger(self.trigger_type)    def _create_trigger(self, trigger_type: str, **kwargs):        """创建触发器"""        match trigger_type:            case TriggerType.Once:                return DateTrigger(run_date=self.run_date)            case TriggerType.Cron:                return _CronTrigger(cron=self.cron)            case TriggerType.FixedRate:                return IntervalTrigger(hours=self.hours)            case _:                raise ValueError(f"Unsupported trigger type: {trigger_type}")    @property    def trigger(self):        return self._trigger    def get_next_runtime(self, now: Optional[datetime] = None) -> Optional[datetime]:        """获取下一次执行时间（返回datetime对象）"""        if now is None:            now = datetime.now()        # 关键修复：对于一次性触发器，previous_fire_time 应该为 None        # 因为我们要获取的是第一次（也是唯一一次）执行时间        return self._trigger.get_next_fire_time(previous_fire_time=None, now=now)    @property    def next_runtime(self) -> str:        """获取下一次执行时间（格式化字符串）"""        next_time = self.get_next_runtime()        if next_time is None:            # 检查是否是过期的一次性任务            if self.trigger_type == TriggerType.Once and hasattr(self._trigger, 'run_date'):                run_date = self._trigger.run_date                now = datetime.now()                if run_date < now:                    return f"Already expired at {run_date.strftime('%Y-%m-%d %H:%M:%S')}"            return "No scheduled time"        return next_time.strftime("%Y-%m-%d %H:%M:%S")    def is_expired(self) -> bool:        """检查一次性任务是否已过期"""        if self.trigger_type != TriggerType.Once:            return False        next_time = self.get_next_runtime()        return next_time is Noneclass _CronTrigger(CronTrigger):    """    Triggers when current time matches all specified time constraints,    similarly to how the UNIX cron scheduler works.    :param int|str year: 4-digit year    :param int|str month: month (1-12)    :param int|str day: day of month (1-31)    :param int|str week: ISO week (1-53)    :param int|str day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)    :param int|str hour: hour (0-23)    :param int|str minute: minute (0-59)    :param int|str second: second (0-59)    :param datetime|str start_date: earliest possible date/time to trigger on (inclusive)    :param datetime|str end_date: latest possible date/time to trigger on (inclusive)    :param datetime.tzinfo|str timezone: time zone to use for the date/time calculations (defaults        to scheduler timezone)    :param int|None jitter: delay the job execution by ``jitter`` seconds at most    .. note:: The first weekday is always **monday**.    """    def __init__(self, cron: str):        values = cron.strip().split()        super().__init__(minute=values[0],                         hour=values[1],                         day=values[2],                         month=values[3],                         day_of_week=values[4], )