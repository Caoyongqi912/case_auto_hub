#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/4/3# @Author : cyq# @File : tasks# @Software: PyCharm# @Desc:import asynciofrom typing import Listfrom enums import StarterEnumfrom interface.starter import APIStarterfrom interface.taskRunner import TaskRunnerfrom play.playTaskRunner import PlayTaskRunnerfrom play.starter import UIStarterfrom utils import logoptions = ["API", "CASE"]async def ui_task(task_id: int):    await PlayTaskRunner(UIStarter(StarterEnum.RoBot)).execute_task(task_id)async def api_task(task_id: int):    await TaskRunner(APIStarter(StarterEnum.RoBot)).handler_execute_task(task_id)async def execute_api_tasks(env_id: int, tasks: List[int], parallel: int):    """    调度添加任务    """    # 顺序执行    if parallel == 0:        for task in tasks:            await TaskRunner(APIStarter(StarterEnum.RoBot)).handler_execute_task(task, env_id, options)    else:        semaphore = asyncio.Semaphore(parallel)        tasks = []        for task_id in tasks:            task = asyncio.create_task(                execute_task_with_semaphore(semaphore=semaphore, task_id=task_id, env_id=env_id)            )            tasks.append(task)        return await asyncio.gather(*tasks)async def execute_task_with_semaphore(semaphore: asyncio.Semaphore, task_id: int, env_id: int):    async with semaphore:  # 限制并行数量        await TaskRunner(APIStarter(StarterEnum.RoBot)).handler_execute_task(task_id, env_id, options)async def run_heartbeat():    """可序列化的心跳任务函数"""    from common import rc    Key = "scheduler:master_lock"    await rc.init_pool()    if await rc.r.get(Key):        await rc.r.expire(Key, 60)        log.debug("✅ Renewed lock")