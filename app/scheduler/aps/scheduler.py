#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/4/3# @Author : cyq# @File : taskClient# @Software: PyCharm# @Desc:from typing import TypeVar, Union, Callablefrom apscheduler.schedulers.asyncio import AsyncIOSchedulerimport asynciofrom app.model.base.job import AutoJobfrom app.scheduler.aps.trigger import Triggerfrom common import RedisClientfrom config import Configfrom enums import TriggerTypeEnumfrom utils import MyLogurufrom .jobs import aps_heartbeat, print_jobs, aps_submit_interface_tasklog = MyLoguru().get_logger()TaskType = TypeVar('TaskType', bound=Union['PlayTask', 'InterfaceTask'])async def run_sync(func: Callable, *args, **kwargs):    return await asyncio.to_thread(func, *args, **kwargs)class HubScheduler:    redis: "RedisClient" = None    def __init__(self):        self._scheduler = AsyncIOScheduler(        )        self.lock_key = "scheduler:master_lock"        self.lock_value = "1"        self.lock_ex = 60    async def initialize(self, redis: "RedisClient") -> bool:        """        初始化、        """        self.redis = redis        # 可以基于项目版本或重启标识来清理        restart_key = f"{self.lock_key}_restart"        # 检查是否是重启后第一次初始化        restart_flag = await self.redis.r.get(restart_key)        if not restart_flag:            # 第一次重启，清理可能存在的旧锁            await self.redis.r.delete(self.lock_key)            # 设置重启标记（有效期稍长，确保重启过程完成）            await self.redis.r.set(restart_key, "1", ex=10)        # 在 Redis 中设置一个分布式锁，锁的键为 self.lock_key，值为 "1"，锁的有效期为 60 秒        acquired = await self.redis.r.set(            self.lock_key,            self.lock_value,            nx=True,            ex=self.lock_ex  # 锁60秒过期        )        if acquired:            self._scheduler.configure(jobstores=Config.APSJobStores,                                      timezone=Config.APS_TZ)            # 启动调度器            self._scheduler.start()            # 心跳            await self._setup_heartbeat()            await self._print_jobs()            log.info("[Scheduler] : Initialized as master")            return True        log.info("[Scheduler] : Initialized as slave (no lock acquired)")        return False    async def add_job(self, func: Callable, trigger: "Trigger", job_id: str, *args, **kwargs):        """        注册任务        """        job = await run_sync(            self._scheduler.add_job,            func,            trigger=trigger.trigger,            id=job_id,            replace_existing=True,            misfire_grace_time=60,  # 允许60秒内的延迟            coalesce=True,  # 确保即使错过多次运行时间，也只运行一次            *args,            **kwargs        )        log.info(f"[Scheduler] : REGISTER JOB {job} SUCCESS")        return job    def sync_get_job(self, job_id: str):        job = self._scheduler.get_job(job_id)        log.info(f"sync_get_job {job}")        return job    async def get_job(self, job_id: str):        return await run_sync(self._scheduler.get_job, job_id)    async def remove_job(self, job_id: str):        """移除任务"""        if not self._scheduler.running:            job = await self.get_job(job_id)            if job:                await run_sync(self._scheduler.remove_job, job_id)                log.info(f"[Scheduler] : Remove Job {job_id} complete")    async def get_jobs(self):        """获取所有任务"""        return await run_sync(self._scheduler.get_jobs)    async def shutdown(self):        """关闭调度器"""        if self._scheduler.running:            await run_sync(self._scheduler.shutdown, wait=True)            log.info("[Scheduler] : Shutdown complete")    async def switch_job(self, job_id: str, enable: bool):        """        暂停与重启任务        :param job_id:        :param enable:        :return:        """        job = await self.get_job(job_id=job_id)        if not job:            log.warning(f"[Scheduler] : switch_job Not Found Job {job_id}")            return        if enable:            await run_sync(                self._scheduler.resume_job,                job_id=job_id            )            log.info(f"[Scheduler] : Job {job_id} Resume Success")        else:            await run_sync(                self._scheduler.pause_job,                job_id=job_id            )            log.info(f"[Scheduler] : Job {job_id} Pause Success")    async def add_auto_job(self, job: AutoJob):        """        添加自动化任务APS        ：param job        """        if job.job_type == 1:            return await self._add_interface_job(job=job)        elif job.job_type == 2:            return await self._add_play_job(job=job)        else:            raise ValueError(f"Invalid job type {job.job_type}")    async def modify(self, job: AutoJob):        """修改已有任务配置"""        _j = await self.get_job(job.uid)        if not _j:            log.warning(f"Job {job.id} not found, creating new one")            return await self.add_auto_job(job)        log.debug(f"modify  {_j}")        _trigger = Trigger(trigger_type=job.job_trigger_type,kw=job.trigger_value)        modify_job = await run_sync(            self._scheduler.modify_job,            trigger=_trigger.trigger,            args=(job,),  # 更新参数            job_id=job.uid,            name=job.job_name,        )        log.info(f"[Scheduler] : MODIFY JOB {modify_job} SUCCESS")    async def _add_interface_job(self, job: AutoJob):        """        接口定时任务        """        _trigger = Trigger(trigger_type=job.job_trigger_type, kw=job.trigger_value)        await self.add_job(            func=aps_submit_interface_task,            trigger=_trigger,            args=(job,),            job_id=job.uid,            name=job.job_name        )    async def _add_play_job(self, job: AutoJob):        """"""    async def _setup_heartbeat(self):        """设置心跳"""        try:            trigger = Trigger(                trigger_type=TriggerTypeEnum.FIXED_RATE,                kw={"seconds": 30}            )            await self.add_job(                func=aps_heartbeat,                trigger=trigger,                job_id="heartbeat",                name="Scheduler Heartbeat"            )        except Exception as e:            log.exception(f"[Scheduler] : Failed to setup heartbeat: {e}")    async def _print_jobs(self):        """        检查任务        """        try:            trigger = Trigger(                trigger_type=TriggerTypeEnum.FIXED_RATE,                kw={"hours": 1}            )            await self.add_job(                func=print_jobs,                trigger=trigger,                job_id="print_jobs",                name="Scheduler JobPrinter"            )        except Exception as e:            log.exception(f"[Scheduler] : Failed to print jobs: {e}")hubScheduler = HubScheduler()