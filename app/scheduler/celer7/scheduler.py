#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/4/7# @Author : cyq# @File : scheduler# @Software: PyCharm# @Desc:import asynciofrom datetime import datetimefrom celery.beat import PersistentSchedulerfrom utils import logclass CeleryScheduler(PersistentScheduler):    """    定时任务调度    """    def __init__(self, *args, **kwargs):        super(CeleryScheduler, self).__init__(*args, **kwargs)        self.last_reload_time = datetime.now()        self.reload_interval = 30  # 每30秒检查一次更新    def setup_schedule(self):        super().setup_schedule()        self._sync_load_initial_schedules()    def _sync_load_initial_schedules(self):        """同步加载初始调度配置"""        try:            from .app import sync_update_schedules            sync_update_schedules()            log.info("✅ 初始定时任务加载完成")        except Exception as e:            log.error(f"❌ 初始定时任务加载失败: {e}")    async def async_reload_schedules(self):        """异步重新加载调度配置"""        try:            from .app import update_all_celery_schedules            success = await update_all_celery_schedules()            if success:                self.last_reload_time = datetime.now()            return success        except Exception as e:            log.error(f"❌ 异步重载定时任务失败: {e}")            return False    def tick(self, *args, **kwargs):        """        重写tick方法，定期检查数据库变更        """        # 检查是否需要重新加载        if self._should_reload():            try:                # 同步调用异步重载                loop = asyncio.new_event_loop()                asyncio.set_event_loop(loop)                loop.run_until_complete(self.async_reload_schedules())                loop.close()            except Exception as e:                log.error(f"定时重载任务失败: {e}")        return super().tick()    def _should_reload(self):        """判断是否需要重新加载"""        return (datetime.now() - self.last_reload_time).seconds >= self.reload_interval