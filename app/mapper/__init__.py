#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : __init__.py# @Software: PyCharm# @Desc:import jsonfrom math import ceilfrom pyparsing import Dictfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy import select, func, and_, text, deletefrom sqlalchemy.sql.functions import countfrom app.exception import NotFind, CommonErrorfrom app.model import async_session, BaseModelfrom typing import TypeVar, List, Type, Any, Optional, Genericfrom app.model.base import Userfrom utils import logdef pages(total, pageSize) -> int:    """The total number of pages."""    if total == 0 or total is None:        return 0    return ceil(total / pageSize)async def set_creator(user: User, **kwargs):    """    设置创建人    :param user:    :param kwargs:    :return:    """    kwargs.update({"creator": user.id, "creatorName": user.username})    return kwargsasync def set_updater(user: User, **kwargs):    """    设置更改人    :param user:    :param kwargs:    :return:    """    kwargs.update({"updater": user.id, "updaterName": user.username})    return kwargsM = TypeVar('M', bound=BaseModel)class Mapper(Generic[M]):    __model__: Type[M] | Any    def __init_subclass__(cls, **kwargs):        super().__init_subclass__(**kwargs)        # 在子类中验证 __model__ 的类型兼容性        if not hasattr(cls, '__model__'):            raise TypeError(f"{cls.__name__} 必须定义 __model__ 类变量")    @classmethod    async def insert(cls, model: M) -> M:        """        模型入库        """        return await cls._manage_session(session=None, model=model)    @classmethod    async def save(cls, creator_user: User = None, session: AsyncSession = None, **kwargs) -> M:        """        保存模型实例到数据库，处理创建人信息并返回模型实例。        return M        """        # 设置创建人信息        if creator_user:            kwargs = await set_creator(creator_user, **kwargs)        try:            # 创建模型实例            model = cls.__model__(**kwargs)            # 处理会话管理            return await cls._manage_session(session, model)        except Exception as e:            log.error(f"保存{cls.__name__}失败: {e}")            raise e    @classmethod    async def copy_one(cls, target_id: int, session: AsyncSession, user: User = None) -> M:        """        复制        """        old_one = await cls.get_by_id(target_id, session)        new_one = cls.__model__(            **old_one.copy_map()        )        if user:            new_one.creator = user.id            new_one.creatorName = user.username        return await cls.add_flush_expunge(session, new_one)    @classmethod    async def get_by_id(cls, ident: int, session: AsyncSession = None, desc: str = '') -> M:        """        通过id获取对象        :param ident: id        :param session: AsyncSession        :param desc: 错误描述        :return:mapper_model        """        model_class = cls.__model__        try:            stmt = select(model_class).where(model_class.id == ident)            # 4. 执行查询            if session is None:                async with async_session() as session:                    result = await session.execute(stmt)                    instance = result.scalar_one_or_none()            else:                result = await session.execute(stmt)                instance = result.scalar_one_or_none()            if not instance:                error_msg = f"数据{desc}不存在或已经删除，ID: {ident}" if desc else f"数据不存在，ID: {ident}"                raise NotFind(error_msg)            return instance        except NotFind:            raise        except Exception as e:            error_detail = f"获取{cls.__name__}对象失败，ID: {ident}"            if desc:                error_detail += f", 描述: {desc}"            log.error(f"{error_detail}, 错误: {e}")            raise e    @classmethod    async def get_by_uid(cls, uid: str, session: AsyncSession = None, raise_error: bool = True) -> M:        """        通过uid获取对象        :param uid: model field uid        :param session:AsyncSession        :param raise_error: 是否抛出异常        :return: model        """        model_class = cls.__model__        try:            stmt = select(model_class).where(model_class.uid == uid)            # 4. 执行查询            if session is None:                async with async_session() as session:                    result = await session.execute(stmt)                    instance = result.scalar_one_or_none()            else:                result = await session.execute(stmt)                instance = result.scalar_one_or_none()            if not instance:                error_msg = f"数据{raise_error}不存在或已经删除，ID: {uid}" if raise_error else f"数据不存在，ID: {uid}"                raise NotFind(error_msg)            return instance        except NotFind:            raise        except Exception as e:            raise e    @classmethod    async def update_by_id(cls, session: AsyncSession = None, updateUser: User = None, **kwargs) -> M:        """        通过id更新        :param session:        :param updateUser:        :param kwargs:        """        try:            ident: int | None = kwargs.pop("id", None)            if ident is None:                raise ValueError("id parameter is required")            kwargs = await set_updater(updateUser, **kwargs)            if not session:                async with async_session() as session:                    target = await cls.get_by_id(ident, session)                    await cls.update_cls(target, session, **kwargs)                    await session.commit()            else:                target = await cls.get_by_id(ident, session)                await cls.update_cls(target, session, **kwargs)                await session.commit()            return target        except Exception as e:            log.exception(e)            raise    @classmethod    async def update_by_uid(cls, updateUser: User = None, **kwargs):        """        通过uid更新        :param updateUser: 修改人        :param kwargs:        """        kwargs = await set_updater(updateUser, **kwargs)        try:            async with async_session() as session:                uid = kwargs.pop("uid")                async with session.begin():                    target = await cls.get_by_uid(uid, session)                    return await cls.update_cls(target, session, **kwargs)        except Exception as e:            raise e    @classmethod    async def delete_by_uid(cls, uid: str):        """        通过uid删除        :param uid:        """        try:            async with async_session() as session:                await session.execute(                    delete(cls.__model__).where(cls.__model__.uid == uid)                )                await session.commit()        except Exception as e:            raise e    @classmethod    async def delete_by_id(cls, ident: int, session: AsyncSession = None):        """        通过id删除        :param ident:        :param session: AsyncSession        """        stmt = delete(cls.__model__).where(cls.__model__.id == ident)        try:            if session:                await session.execute(stmt)                await session.commit()            else:                async with async_session() as session:                    await session.execute(stmt)                    await session.commit()        except Exception as e:            log.exception(e)            raise e    @classmethod    async def delete_by(cls, session: AsyncSession, **kwargs):        """        通过属性删除        """        try:            model = cls.get_by(session, **kwargs)            if model:                await session.delete(model)                await session.flush()        except Exception as e:            raise e    @classmethod    async def get_by(cls, session: AsyncSession = None, **kwargs) -> M:        """        通过field获取对象        :param session        :return: mapper_model        """        sql = select(cls.__model__).filter_by(**kwargs)        try:            if session is None:                async with async_session() as session:                    result = await session.scalars(sql)            else:                result = await session.scalars(sql)            return result.first()        except Exception as e:            raise e    @classmethod    async def query_all(cls) -> List[M]:        """        查询所有        :return:mapper_model        """        try:            async with async_session() as session:                query = await session.scalars(select(cls.__model__))                return query.all()        except Exception as e:            raise e    @classmethod    async def query_by(cls, **kwargs):        """        通过字段查询 and 查询        :param kwargs: {xx:xx }        :return:        """        try:            async with async_session() as session:                query = await session.scalars(                    select(cls.__model__).filter_by(**kwargs).order_by(cls.__model__.create_time))                return query.all()        except Exception as e:            raise e    @classmethod    async def query_by_in_clause(cls, target: str, list_: List[Any]):        """        根据指定字段和值列表查询数据。        :param target: 模型中的字段名        :param list_: 用于 IN 子句的值列表        :return: 查询结果列表或错误信息        """        # 输入验证        if not hasattr(cls.__model__, target):            raise CommonError("Invalid field name")        try:            async with async_session() as session:                stmt = select(cls.__model__).where(                    getattr(cls.__model__, target).in_(list_)                )                query = await session.scalars(stmt)                return query.all()        except Exception as e:            raise e    @staticmethod    async def flush_expunge(session: AsyncSession, model: M):        """        此方法用于确保数据库中的数据与会话中的对象状态同步。它首先强制会话提交所有未提交的更改，        然后刷新指定模型实例，以从数据库中重新加载其状态。最后，它从会话中移除该实例，断开        其与会话的关联。        参数:        - session: AsyncSession类型的参数，表示当前的异步数据库会话。        - model: 模型类的实例，表示需要刷新和从会话中移除的对象。        :param session:        :param model:        :return:        """        await session.flush()        await session.refresh(model)        session.expunge(model)    @classmethod    async def page_query(cls, current: int, pageSize: int, **kwargs):        """        分页        :param current:        :param pageSize:        :param kwargs:        :return:        """        try:            async with async_session() as session:                # 处理条件                conditions = await cls.search_conditions(**kwargs)                # 查询                base_query = select(cls.__model__).filter(and_(*conditions))                # 排序                base_query = await cls.sorted_search(base_query, kwargs.pop("sort", None))                base = select(func.count()).select_from(cls.__model__)                # Get total count                total_query = base.filter(*conditions)                total = (await session.execute(total_query)).scalar()                # Paginate and execute                paginated_query = base_query.offset((current - 1) * pageSize).limit(pageSize)                exe = await session.execute(paginated_query)                data = exe.scalars().all()                return await cls.map_page_data(data,                                               total,                                               pageSize,                                               current)        except Exception as e:            raise e    @classmethod    async def get_creator(cls, creatorId: int, session: AsyncSession) -> User:        """        获取创建人信息        :param creatorId:        :param session:        :return:        """        exe = await session.execute(            select(User).where(User.id == creatorId)        )        user = exe.scalar()        if not user:            raise NotFind("创建人信息不存在")        return user    @staticmethod    async def add_flush_expunge(session: AsyncSession, model: M):        """        异步将模型添加到数据库会话中，刷新并分离模型。        此函数执行以下操作：        1. 将模型添加到数据库会话中。        2. 刷新会话，将此会话中的更改同步到数据库。        3. 从会话中分离模型，使其成为一个独立的对象，可以重新附加到其他会话。        参数：        - session: AsyncSession - 异步数据库会话。        - model: M - 要添加到会话中的模型对象，类型为泛型 M。        注意：此函数不会提交更改到数据库，它只是将更改暂存并准备模型以进行后续操作。        """        # 将模型添加到会话中        session.add(model)        # 刷新会话，将更改同步到数据库但不提交 # 会生成主键        await session.flush()        # 从会话中分离模型，使其成为独立对象 避免重复提交        session.expunge(model)        return model    @classmethod    async def update_cls(cls, target: M, session: AsyncSession, **kw):        """更新"""        try:            # 过滤有效的更新字段            valid_columns = set(cls.__model__.__table__.columns.keys())            update_fields = {k: v for k, v in kw.items() if k in valid_columns}            # 更新目标对象属性            for field, value in update_fields.items():                setattr(target, field, value)            # 刷新会话并处理可能的异常            await session.flush()            # 从会话中分离模型，使其成为独立对象            session.expunge(target)            return target        except Exception as e:            raise e    @classmethod    async def sorted_search(cls, base_query, sortInfo: str | Dict = None):        """        排序 默认倒叙        :param base_query        :param sortInfo: 查询条件        :return:        """        sort = None        try:            if isinstance(sortInfo, str):                sort = json.loads(sortInfo)                if not isinstance(sort, dict):                    raise ValueError("Invalid JSON format")            elif isinstance(sortInfo, dict):                sort = sortInfo        except (TypeError, json.JSONDecodeError, ValueError):            pass        # 排序        if sort:            for k, v in sort.items():                if v == "descend":                    base_query = base_query.order_by(getattr(cls.__model__, k).desc())                else:                    base_query = base_query.order_by(getattr(cls.__model__, k).asc())        else:            base_query = base_query.order_by(cls.__model__.create_time.desc())        return base_query    @classmethod    async def search_conditions(cls, **kwargs) -> List:        """        查询条件        参数:        **kwargs: 查询条件参数，支持多种条件类型:            - 范围查询: 使用列表或元组 [min, max]            - 模糊查询: 字符串自动添加 % 通配符            - 精确匹配: 数字、布尔值、None        """        # 条件        conditions = []        for k, v in kwargs.items():            if v is None:                conditions.append(getattr(cls.__model__, k) is None)                continue            # v is [] -> between            if isinstance(v, (tuple, list)):                conditions.append(                    and_(                        getattr(cls.__model__, k) >= v[0],                        getattr(cls.__model__, k) <= v[1]                    )                )                continue            if isinstance(v, str):                conditions.append(                    getattr(cls.__model__, k).like(f"%{v}%")                )                continue            if isinstance(v, (int, float, bool)):                conditions.append(                    getattr(cls.__model__, k) == v                )                continue            else:                continue        return conditions    @classmethod    async def map_page_data(cls, data: List, totalNum: int, pageSize: int, current: int):        results = {            "items": data,            "pageInfo": {                "total": totalNum,                "pages": pages(totalNum, pageSize),                "page": current,                "limit": pageSize            }        }        return results    @classmethod    async def count_(cls):        try:            async with async_session() as session:                sql = select(count()).select_from(cls.__model__)                state = await session.execute(sql)                return state.scalar()        except Exception:            return 0    @classmethod    async def tables(cls):        try:            sql = """                  SELECT TABLE_NAME    AS table_name,                         TABLE_COMMENT AS table_description                  FROM information_schema.TABLES                  WHERE TABLE_SCHEMA = DATABASE(); \                  """            async with async_session() as session:                # 使用ORM方式查询表名                result = await session.execute(text(sql))                data = result.fetchall()                log.debug(data)                return [row[0] for row in result.fetchall()]        except Exception as e:            log.error(e)            return []    @classmethod    async def page_by_module(cls, current: int, pageSize: int, module_type: int, module_id: int = None, **kwargs):        Attr = "module_id"        try:            async with async_session() as session:                from app.mapper.project.moduleMapper import get_subtree_ids                subtree_ids = await get_subtree_ids(session, module_id, module_type)                # 构建基础查询                base_query = select(cls.__model__).filter(getattr(cls.__model__, Attr).in_(subtree_ids)                                                          )                conditions = await cls.search_conditions(**kwargs)                base_query = base_query.filter(and_(*conditions))                base_query = await cls.sorted_search(base_query, kwargs.pop("sort", None))                # 获取总数                total_query = select(func.count()).select_from(cls.__model__).filter(                    getattr(cls.__model__, Attr).in_(subtree_ids),                    *conditions  # 直接传递条件，避免重复构建                )                total = (await session.execute(total_query)).scalar()                # 分页查询                paginated_query = base_query.offset((current - 1) * pageSize).limit(pageSize)                data = (await session.execute(paginated_query)).scalars().all()                # 返回分页结果                return await cls.map_page_data(data, total, pageSize, current)        except Exception as e:            log.error(e)            return []    @classmethod    async def _manage_session(cls, session: Optional[AsyncSession], model: M) -> M:        """        管理会话，检查是否传递了会话，如果没有则使用默认会话。        """        if session is None:            async with async_session() as new_session:                async with new_session.begin():                    return await cls.add_flush_expunge(new_session, model)        return await cls.add_flush_expunge(session, model)