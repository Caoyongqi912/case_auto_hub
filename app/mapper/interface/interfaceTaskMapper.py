#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/20# @Author : cyq# @File : interfaceTaskMapper# @Software: PyCharm# @Desc:from typing import List, Anyfrom sqlalchemy import select, insertfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper import Mapperfrom app.model import async_sessionfrom app.model.interface import InterfaceTask, case_task_association, InterFaceCaseModelfrom utils import MyLogurulog = MyLoguru().get_logger()class InterfaceTaskMapper(Mapper):    __model__ = InterfaceTask    @classmethod    async def query_case(cls, taskId: int) -> List[InterFaceCaseModel]:        """查询所有用例"""        try:            async with async_session() as session:                cases = await session.scalars(                    select(InterFaceCaseModel).join(                        case_task_association,                        case_task_association.c.inter_case_id == InterFaceCaseModel.id                    ).where(                        case_task_association.c.task_id == taskId                    ).order_by(                        case_task_association.c.step_order                    )                )                return cases.all()        except Exception as e:            raise e    @classmethod    async def association_cases(cls, taskId: int, caseIds: List[int]):        """        关联用例 与任务        :param taskId:        :param caseIds:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    if not caseIds:                        return                    task: InterfaceTask = await cls.get_by_id(ident=taskId, session=session)                    task.total_cases_num += len(caseIds)                    last_case_index = await InterfaceTaskMapper.get_last_index(session=session, taskId=taskId)                    for index, caseId in enumerate(caseIds, start=last_case_index + 1):                        await session.execute((insert(case_task_association).values(                            dict(                                task_id=taskId,                                inter_case_id=caseId,                                step_order=index                            )                        )))        except Exception as e:            raise e    @classmethod    async def remove_association_case(cls, taskId: int, caseId: int):        """        接触关联        :param taskId:        :param caseId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    task: InterfaceTask = await cls.get_by_id(ident=taskId, session=session)                    # 删除关联表数据                    await session.execute(case_task_association.delete().where(                        case_task_association.c.inter_case_id == caseId,                        case_task_association.c.task_id == taskId                    ))                    # 重新排序                    cases = await session.execute(                        select(InterFaceCaseModel).join(                            case_task_association,                            case_task_association.c.inter_case_id == InterFaceCaseModel.id                        ).where(                            case_task_association.c.task_id == taskId,                        ).order_by(                            case_task_association.c.step_order                        )                    )                    cases = cases.scalars().all()                    task.total_cases_num = len(cases)                    for index, case in enumerate(cases, start=1):                        sql = case_task_association.update().where(                            (case_task_association.c.inter_case_id == case.id) &                            (case_task_association.c.task_id == task.id)                        ).values(step_order=index)                        await session.execute(sql)        except Exception as e:            raise e    @classmethod    async def reorder_cases(cls, taskId: int, caseIds: List[int]):        """        重新排序关联        :param taskId:        :param caseIds:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    for index, caseId in enumerate(caseIds, start=1):                        sql = case_task_association.update().where(                            (case_task_association.c.inter_case_id == caseId) &                            (case_task_association.c.task_id == taskId)                        ).values(step_order=index)                        await session.execute(sql)        except Exception as e:            raise e    @staticmethod    async def get_last_index(session: AsyncSession, taskId: int) -> int:        try:            sql = (                select(case_task_association.c.step_order).where(                    case_task_association.c.task_id == taskId                ).order_by(case_task_association.c.step_order.desc()).limit(1)            )            log.debug(sql)            result = await session.execute(sql)            last_step_order = result.scalar()  # Fetch the first (and only) result            return last_step_order or 0        except Exception as e:            raise e