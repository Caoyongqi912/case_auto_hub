#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/20# @Author : cyq# @File : interfaceMapper# @Software: PyCharm# @Desc:import asyncioimport osfrom typing import List, Dict, Anyfrom sqlalchemy import select, insert, and_, delete, updatefrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper import Mapperfrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.project.moduleMapper import ModuleMapperfrom app.model import async_sessionfrom app.model.base import Userfrom app.model.base.module import Modulefrom app.model.interface import InterfaceModelfrom app.model.interface.InterfaceCaseStepContent import InterfaceConditionfrom app.model.interface.association import ConditionAPIAssociationfrom app.model.interface.interfaceScriptDescModel import InterfaceScriptDescfrom enums import ModuleEnumfrom interface.recoder import Recordfrom utils.fileManager import API_DATAfrom utils import MyLogurulog = MyLoguru().get_logger()class InterfaceMapper(Mapper):    __model__ = InterfaceModel    @classmethod    async def copy_to_module(cls, inter_id: int, project_id: int, module_id: int, user: User):        try:            async with async_session() as session:                async with session.begin():                    copyInter = await cls.copy_api(apiId=inter_id, creator=user, session=session, is_common=True)                    copyInter.project_id = project_id                    copyInter.module_id = module_id                    copyInter = await cls.add_flush_expunge(session=session, model=copyInter)                    log.info(copyInter)                    return copyInter        except Exception as e:            raise e    @staticmethod    async def remove_data_file(api: InterfaceModel):        """        删除 data 附件        """        api_datas = api.data        if api_datas and api.body_type == 2:            for data in api_datas:                if data.get("value") and f"{api.uid}_" in data.get("value"):                    filepath = os.path.join(API_DATA, data.get('value'))                    # 确保文件存在并可读                    if os.path.exists(filepath):                        os.remove(filepath)                        log.info(f"删除文件成功: {filepath}")    @staticmethod    async def update_data_file(api: InterfaceModel):        """        更新 data file 的逻辑：        1. 如果 data 存在且 body_type 为 2，则检查并删除符合条件的文件。        2. 如果 data 为空，则删除以 api.uid_* 开头的目录。        3. 如果 data 不存在，则删除对应的目录。        """        api_datas = api.data        if api_datas and api.body_type == 2:            for data in api_datas:                value = data.get("value")                if value and f"{api.uid}_" in value:                    filepath = os.path.join(API_DATA, value)                    # 校验路径是否合法                    if not os.path.abspath(filepath).startswith(os.path.abspath(API_DATA)):                        log.error(f"非法路径尝试: {filepath}")                        continue                    try:                        # 确保文件存在并可读                        if os.path.exists(filepath) and os.path.isfile(filepath):                            os.remove(filepath)                            log.info(f"删除文件成功: {filepath}")                    except Exception as e:                        log.error(f"删除文件失败: {filepath}, 错误信息: {e}")        elif not api_datas:            # 如果 data 为空，删除以 api.uid_* 开头的目录            try:                if not os.path.exists(API_DATA):                    return                for dir_name in os.listdir(API_DATA):                    if dir_name.startswith(f"{api.uid}_"):                        dir_path = os.path.join(API_DATA, dir_name)                        if os.path.isdir(dir_path):                            os.rmdir(dir_path)  # 删除空目录                            log.info(f"删除目录成功: {dir_path}")            except Exception as e:                log.error(f"删除目录失败: {e}")        else:            # 如果 data 不存在，删除对应的目录            target_dir = os.path.join(API_DATA, f"{api.uid}_*")            if not os.path.exists(target_dir):                return            if os.path.exists(target_dir) and os.path.isdir(target_dir):                try:                    os.rmdir(target_dir)                    log.info(f"删除目录成功: {target_dir}")                except Exception as e:                    log.error(f"删除目录失败: {target_dir}, 错误信息: {e}")    @classmethod    async def set_interfaces_modules(cls, module_id: int, interfaces: List[int]):        """        设置接口 所属模块        """        try:            async with async_session() as session:                async with session.begin():                    stmt = update(InterfaceModel).where(                        InterfaceModel.id.in_(interfaces)                    ).values(module_id=module_id)                    await session.execute(stmt)        except Exception as e:            raise e    @classmethod    async def upload(cls, apis: List[Dict[str, Any]], project_id: str, module_id: str, env_id: str, creator: User):        """        批量上传 API 数据并插入到数据库。        :param apis: API 数据列表        :param project_id: 项目 ID        :param module_id: 父级 Module ID        :param env_id: 环境 ID        :param creator: 创建者用户对象        :return: None        """        try:            async with async_session() as session:                async with session.begin():                    # 提取并插入 Module                    module_names = [api.pop("module") for api in apis]                    modules = []                    for name in set(module_names):                        modules.append(await cls.insert_module(name, session, int(module_id), int(project_id), creator))                    # 插入 API 数据                    api_tasks = [                        cls.insert_inter_with_semaphore(session,                                                        int(project_id),                                                        int(env_id),                                                        modules[index], creator, api["data"])                        for index, api in enumerate(apis)                    ]                    await asyncio.gather(*api_tasks, return_exceptions=True)        except Exception as e:            log.error(f"Error in upload method: {e}")            raise    @staticmethod    async def insert_inter_with_semaphore(            session: AsyncSession, project_id: int, env_id: int, module_id: int, creator: User,            data: List[Dict[str, Any]]    ):        """        插入 API 数据到数据库，使用 Semaphore 控制并发度。        :param session: 数据库会话        :param project_id: 项目 ID        :param env_id: 环境 ID        :param module_id: module_id        :param creator: 创建者用户对象        :param data: API 数据列表        """        semaphore = asyncio.Semaphore(5)  # 同时最多允许5个并发任务        async with semaphore:            try:                for api_data in data:                    api_data.update({                        "project_id": project_id,                        "env_id": env_id,                        "module_id": module_id,                        "creator": creator.id,                        "creatorName": creator.username,                        "status": "DEBUG",                        "level": "P1",                    })                    api = InterfaceModel(**api_data)                    session.add(api)            except Exception as e:                log.error(f"Error in insert_inter_with_semaphore: {e}")                raise    @staticmethod    async def insert_module(            module_name: str, session: AsyncSession, parent_id: int, project_id: int, creator: User    ) -> int:        """        :param module_name: 部门 名称        :param session: 数据库会话        :param parent_id: 父级 部门 ID        :param project_id: 项目 ID        :param creator: 创建者用户对象        :return: 插入的 部门 ID        """        try:            # 获取父级 Module 和子 module 是否存在            parent_module = await ModuleMapper.get_by_id(parent_id, session)            _exist = await  session.execute(                select(Module).where(                    and_(                        Module.project_id == parent_id,                        Module.title == module_name,                        Module.module_type == ModuleEnum.API                    )                )            )            existing_module: Module = _exist.scalar_one_or_none()            if existing_module and module_name == existing_module.title:                log.debug(f"子部门 '{module_name}' 已存在")                return existing_module.id            # 创建新的部门            child_module = Module(                title=module_name,                project_id=project_id,                parent_id=parent_module.id,                creator=creator.id,                creatorName=creator.username            )            session.add(child_module)            await session.flush()            return child_module.id        except Exception as e:            log.error(f"Error in child_module : {e}")            raise    @classmethod    async def remove(cls, interId: int):        """            删除api接口            关联删除处理            api task association            api group association            api case association            api file        """        try:            async with async_session() as session:                async with session.begin():                    api: InterfaceModel = await cls.get_by_id(interId, session)                    await InterfaceMapper.remove_data_file(api)                    from .interfaceTaskMapper import InterfaceTaskMapper                    await InterfaceTaskMapper.set_task_when_api_remove(session, interId)                    await InterfaceGroupMapper.set_group_when_api_remove(session, interId)                    # await InterfaceCaseMapper.set_case_when_api_remove(session, interId)                    await session.delete(api)                    await session.flush()        except Exception as e:            raise e    @staticmethod    async def copy_record_2_api(recordId: str, creator: User):        """        录制转API        """        try:            recordInfos = await Record.query_record(creator.uid)            if not recordInfos:                raise Exception("未查询到录制信息")            for record in recordInfos:                if record.get("uid") == recordId:                    kwargs = {                        "env_id": -1,                        "url": record['url'],                        "desc": record['url'],                        "method": record['method'],                        "headers": record['headers'],                        "params": record['params'],                        "data": record['data'],                        "body": record['body'],                        "body_type": record['body_type']                    }                    return kwargs        except Exception as e:            raise e    @classmethod    async def save_record(cls, creatorUser: User, recordId: str, **kwargs):        """        录制转API        """        try:            record = await cls.copy_record_2_api(recordId, creatorUser)            kwargs.update(record)            return await cls.save(creatorUser=creatorUser, **kwargs)        except Exception:            raise    @classmethod    async def copy_api(cls, apiId: int, creator: User, session: AsyncSession = None,                       is_copy_name: bool = False, is_common: bool = False) -> "InterfaceModel":        """        复制API        :param apiId: 待复制API        :param creator: 创建人        :param session: session        :param is_copy_name: 复制api name        :param is_common: 复制api  common        """        try:            # 封装为一个内部函数，减少重复代码            async def copy_api_logic(logic_session: AsyncSession):                target_api = await cls.get_by_id(ident=apiId, session=logic_session)                target_api_map = target_api.copy_map                if not is_copy_name:                    target_api_map['name'] = target_api_map['name'] + "(副本)"                new_api = cls.__model__(                    **target_api_map,                )                new_api.creator = creator.id                new_api.creatorName = creator.username                new_api.is_common = is_common                await cls.add_flush_expunge(logic_session, new_api)                return new_api            # 使用一个session上下文管理器，如果没有传入session则创建一个            if session is None:                async with async_session() as session:                    async with session.begin():                        return await copy_api_logic(session)            else:                # 如果传入了session，直接使用它                return await copy_api_logic(session)        except Exception as e:            raise eclass InterfaceScriptMapper(Mapper):    __model__ = InterfaceScriptDescclass InterfaceFuncMapper(Mapper):    __model__ = InterfaceScriptDescasync def get_condition_apis_last_index(api_id: int, session: AsyncSession) -> int:    """    查询 条件子步骤最后的索引    """    stmt = select(ConditionAPIAssociation.step_order).where(        ConditionAPIAssociation.api_id == api_id    ).order_by(        ConditionAPIAssociation.step_order.desc()    ).limit(1)    result = await session.execute(stmt)    last_step_order = result.scalar()  # Fetch the first (and only) result    return last_step_order or 0class InterfaceConditionMapper(Mapper):    __model__ = InterfaceCondition    @classmethod    async def add_empty_condition(cls, session: AsyncSession, user: User):        """        初始化一个空条件        """        condition = InterfaceCondition(            creator=user.id,            creatorName=user.username,        )        return await cls.add_flush_expunge(            session,            condition,        )    @classmethod    async def query_condition_apis_by_content_id(cls, content_condition_id: int):        """        通过代理API 查询到condition。        再通过关联表 查询子步骤        查询 条件子步骤        """        async with async_session() as session:            condition: InterfaceCondition = await cls.get_by_id(ident=content_condition_id, session=session)            stmt = select(InterfaceModel).join(ConditionAPIAssociation).where(                ConditionAPIAssociation.condition_id == condition.id,                InterfaceModel.id == ConditionAPIAssociation.api_id            ).order_by(                ConditionAPIAssociation.step_order            )            result = await session.scalars(stmt)            return result.all()    @classmethod    async def remove_condition(cls, condition_id: int, session: AsyncSession):        """        移除条件        """        # 删除API 所有关联        await session.execute(            delete(InterfaceCondition).where(                InterfaceCondition.id == condition_id            )        )    @classmethod    async def association_apis(cls, condition_id: int, interface_id_list: List[int]):        """        条件添加子API        """        async with async_session() as session:            last_index = await get_condition_apis_last_index(condition_id, session)            values = [                {                    "condition_id": condition_id,                    "api_id": interface_id,                    "step_order": index                } for index, interface_id in enumerate(interface_id_list, start=last_index + 1)            ]            await session.execute(                insert(ConditionAPIAssociation).values(                    values                )            )            await session.commit()    @classmethod    async def remove_association_api(cls, condition_id: int, interface_id: int):        """        解除关联        """        async with async_session() as session:            await session.execute(                delete(ConditionAPIAssociation).where(                    and_(                        ConditionAPIAssociation.condition_id == condition_id,                        ConditionAPIAssociation.api_id == interface_id                    )                )            )            await session.commit()    @classmethod    async def reorder_condition_apis(cls, condition_id: int, interface_id_list: List[int]):        """        子步骤重新排序        """        async with async_session() as session:            # 先删除该条件下的所有关联            await session.execute(                delete(ConditionAPIAssociation).where(                    ConditionAPIAssociation.condition_id == condition_id                )            )            values = []            for index, interface_id in enumerate(interface_id_list, start=1):                values.append({                    "condition_id": condition_id,                    "api_id": interface_id,                    "step_order": index                })            await session.execute(                insert(ConditionAPIAssociation).values(                    values                )            )            await session.commit()