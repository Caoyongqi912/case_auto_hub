#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : uiMapper# @Software: PyCharm# @Desc:from typing import List, Type, Sequencefrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper.ui.uiCaseVariableMapper import UICaseVariableMapperfrom app.mapper.ui.uiSubStepMapper import SubStepMapperfrom app.model import async_sessionfrom sqlalchemy import select, and_, update, delete, insertfrom app.model.ui import UICaseModel, UIStepAPIModel, UIStepSQLModel, CaseStepAssociation, UICaseStepsModel, \    SubStepModelfrom app.model.base import Userfrom app.mapper import Mapper, Tfrom enums.CaseEnum import CaseLevel, CaseStatusfrom utils import logasync def insert_CaseStepAssociation(session: AsyncSession, caseId: int, stepId: int, step_order: int):    """    插入关联 case step    如果存在 返回 False，否则插入并返回 True    :param session: 异步会话对象    :param caseId: 关联的用例 ID    :param stepId: 关联的步骤 ID    :param step_order: 步骤顺序    :return: 是否成功插入    """    try:        # 检查是否存在相同的 case_id 和 step_id        result = await session.execute(            select(CaseStepAssociation).where(                and_(                    CaseStepAssociation.ui_case_id == caseId,                    CaseStepAssociation.ui_case_step_id == stepId                )            )        )        if result.scalar() is not None:            return False        await session.execute(insert(CaseStepAssociation).values(            ui_case_id=caseId,            ui_case_step_id=stepId,            step_order=step_order        ))        return True    except Exception as e:        raise easync def get_case_step_last_index(session: AsyncSession, caseId: int) -> int:    """    异步获取指定用例的最后一个步骤索引。    该函数查询数据库以找到给定用例ID的最大步骤顺序值，从而确定该用例的最后一个步骤索引。    参数:    - session: AsyncSession - 异步数据库会话对象，用于执行数据库查询。    - caseId: int - 用例ID，用于过滤与此用例关联的步骤。    返回:    - int - 用例的最后一个步骤索引。如果没有找到该用例的步骤，则返回0。    """    try:        result = await session.execute(select(CaseStepAssociation.step_order)                                       .where(CaseStepAssociation.ui_case_id == caseId)                                       .order_by(CaseStepAssociation.step_order.desc())                                       .limit(1))        last_step_order = result.scalar()        return last_step_order or 0    except Exception as e:        raise eclass UICaseMapper(Mapper):    __model__ = UICaseModel    @classmethod    async def copy_case(cls, caseId: str, cr: User) -> UICaseModel:        """        复制用例        复制step subStep ..        复制关联        """        try:            async with async_session() as session:                async with session.begin():                    old_case = await cls.get_by_uid(caseId, session=session)                    old_steps = await cls.query_steps_by_caseId(old_case.id, session)                    new_case = old_case.copy_map                    new_case['title'] = f"{new_case['title']} (副本)"                    new_case['creator'] = cr.id                    new_case['creatorName'] = cr.username                    new_case['level'] = CaseLevel.getValue(new_case['level'])                    new_case['status'] = CaseStatus.getValue(new_case['status'])                    new_case = await cls.save_no_session(session, **new_case)                    await UICaseVariableMapper.copy_vars(old_case.id, new_case.id, session, cr)                    await UICaseStepMapper.copy_step_form_case(session, new_case.id, old_steps, cr)                    return new_case        except Exception as e:            raise e    @staticmethod    async def query_steps_by_caseId(caseId: int, session: AsyncSession = None) -> Sequence[UICaseStepsModel]:        """        查询用例步骤        :param caseId:        :param session:        :return:        """        stmt = select(UICaseStepsModel).join(            CaseStepAssociation,            CaseStepAssociation.ui_case_step_id == UICaseStepsModel.id        ).where(            CaseStepAssociation.ui_case_id == caseId        ).order_by(            CaseStepAssociation.step_order        )        try:            if session:                steps = await session.scalars(stmt)                return steps.all()            else:                async with async_session() as session:                    steps = await session.scalars(stmt)                    return steps.all()        except Exception as e:            raise e    @classmethod    async def add_step(cls, case_id: int, **kwargs):        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    case = await cls.get_by_id(ident=case_id, session=session)                    kwargs['creator'] = case.creator                    kwargs['creatorName'] = case.creatorName                    # 插入 step                    step = await UICaseStepMapper.save_no_session(session=session,                                                                  **kwargs)                    last_step_order = await get_case_step_last_index(session, case_id)                    if await insert_CaseStepAssociation(session, case.id, step.id, last_step_order + 1):                        case.step_num += 1        except Exception as e:            raise e    @classmethod    async def add_choices(cls, caseId: int, choices: List[int]):        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    case = await cls.get_by_id(ident=caseId, session=session)                    last_step_index = await get_case_step_last_index(session, caseId)                    for index, stepId in enumerate(choices, start=last_step_index + 1):                        if await insert_CaseStepAssociation(session, caseId, stepId, index):                            case.step_num += 1        except Exception as e:            raise e    @classmethod    async def add_copy(cls, caseId: int, choices: List[int]):        """        对选择进行复制后关联        """        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    case = await cls.get_by_id(ident=caseId, session=session)                    last_step_index = await get_case_step_last_index(session, caseId)                    # 查询step                    for stepId in choices:                        step: UICaseStepsModel = await UICaseStepMapper.get_by_id(ident=stepId, session=session)                        # 插入 step                        temp_step = step.copy_map                        temp_step['creator'] = case.creator                        temp_step['creatorName'] = case.creatorName                        temp_step['is_common_step'] = False                        new_step = await UICaseStepMapper.save_no_session(session=session,                                                                          **temp_step)                        if await insert_CaseStepAssociation(session, case.id, new_step.id, last_step_index + 1):                            case.step_num += 1        except Exception as e:            raise eclass UICaseStepMapper(Mapper):    __model__ = UICaseStepsModel    @classmethod    async def query_steps_by_caseId(cls, caseId: int):        try:            async with async_session() as session:                sql = select(UICaseStepsModel).join(                    CaseStepAssociation,                    CaseStepAssociation.ui_case_step_id == UICaseStepsModel.id                ).where(                    CaseStepAssociation.ui_case_id == caseId                ).order_by(CaseStepAssociation.step_order)                exe = await session.execute(sql)                return exe.scalars().all()        except Exception as e:            raise e    @classmethod    async def remove_step(cls, stepId: int, caseId: int = None):        """        如果 caseId 不为空 判断是否 是公共 如果是删除关联表        如果不是删除步骤、删除关联        如果为空        直接删除        :param stepId:        :param caseId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    # 查询步骤                    step = await cls.get_by_id(ident=stepId, session=session)                    if caseId is not None:                        case = await UICaseMapper.get_by_id(ident=caseId, session=session)                        case.step_num -= 1                        # 删除关联表                        await session.execute(                            delete(CaseStepAssociation).where(                                and_(                                    CaseStepAssociation.ui_case_step_id == stepId,                                    CaseStepAssociation.ui_case_id == caseId                                )                            )                        )                        if not step.is_common_step:                            # 删除步骤                            await session.delete(step)                    else:                        # 直接删除步骤                        await session.delete(step)        except Exception as e:            raise e    @classmethod    async def reorder_step(cls, caseId: int, stepIds: [int]):        """        根据steps 重新排序        """        try:            async with async_session() as session:                async with session.begin():                    for index, stepId in enumerate(stepIds, start=1):                        await session.execute(                            update(CaseStepAssociation).where(                                and_(                                    CaseStepAssociation.ui_case_step_id == stepId,                                    CaseStepAssociation.ui_case_id == caseId                                )                            ).values(                                step_order=index                            )                        )        except Exception as e:            raise e    @staticmethod    async def copy_step_form_case(session: AsyncSession, caseId: int, oldSteps: Sequence[UICaseStepsModel], cr: User):        """        复制step        复制api 、 sql、condition        插入关联表        """        try:            for index, step in enumerate(oldSteps, start=1):                # 插入 step                new_step = step.copy_map                new_step['creator'] = cr.id                new_step['creatorName'] = cr.username                new_step = await UICaseStepMapper.save_no_session(session=session,                                                                  **new_step)                if new_step.has_sql:                    await UICaseStepSQLMapper.copy_sql(session, step.id, new_step.id, cr)                if new_step.has_api:                    await UICaseStepApiMapper.copy_api(session, step.id, new_step.id, cr)                if new_step.has_condition:                    await SubStepMapper.copy_sub(session, step.id, new_step.id, cr)                await insert_CaseStepAssociation(session, caseId, new_step.id, index)        except Exception as e:            raise e    @classmethod    async def copy_step(cls, caseId: int, stepId: int):        try:            async with async_session() as session:                async with session.begin():                    # 查询步骤                    step: UICaseStepsModel = await cls.get_by_id(ident=stepId, session=session)                    # 查询case                    case = await UICaseMapper.get_by_id(ident=caseId, session=session)                    case.step_num += 1                    # 插入 step                    temp_step = step.copy_map                    temp_step['name'] = f"{temp_step['name']} (副本)"                    temp_step['creator'] = case.creator                    temp_step['creatorName'] = case.creatorName                    temp_step['is_common_step'] = False                    temp_step['has_api'] = False                    temp_step['has_sql'] = False                    temp_step['has_condition'] = False                    temp_step['condition'] = None                    new_step = await cls.save_no_session(session=session,                                                         **temp_step)                    # last_step_order                    last_step_order = await get_case_step_last_index(session, caseId)                    await insert_CaseStepAssociation(session, case.id, new_step.id, last_step_order + 1)                    log.debug(f"last_step_order = {last_step_order}")        except Exception as e:            raise e    @classmethod    async def add_condition(cls, stepId: int, key: str, value: str, operator: int):        """        添加条件        :param stepId:        :param key:        :param value:        :param operator:        :return:        """        try:            async with async_session() as session:                data = {"key": key, "value": value, "operator": operator}                step = await cls.get_by_id(ident=stepId, session=session)                step.has_condition = True                step.condition = data                await session.commit()                await session.close()        except Exception as e:            raise e    @classmethod    async def update_condition(cls, stepId: int, key: str, value: str, operator: int):        """        跟新条件        :param stepId:        :param key:        :param value:        :param operator:        :return:        """        try:            async with async_session() as session:                data = {"key": key, "value": value, "operator": operator}                step = await cls.get_by_id(ident=stepId, session=session)                step.has_condition = True                step.condition = data                await session.commit()                await session.close()        except Exception as e:            raise e    @classmethod    async def remove_condition(cls, stepId: int):        """        添加条件        :param stepId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    # 跟新step                    await session.execute(                        update(cls.__model__).where(                            cls.__model__.id == stepId                        ).values(                            has_condition=False,                            condition=None                        )                    )                    await session.execute(                        delete(SubStepModel).where(                            SubStepModel.stepId == stepId                        )                    )        except Exception as e:            raise eclass UICaseStepSQLMapper(Mapper):    __model__ = UIStepSQLModel    @classmethod    async def copy_sql(cls, session: AsyncSession, oldStepId: int, newStepId: int, cr: User):        try:            old_sql = await cls.get_by(session, stepId=oldStepId)            if old_sql:                new_sql = old_sql.copy_map                new_sql['creator'] = cr.id                new_sql['creatorName'] = cr.username                new_sql['stepId'] = newStepId                await cls.save_no_session(session, **new_sql)        except Exception as e:            raise e    @classmethod    async def insert(cls: Type[T], creator: User, stepId: int, **kwargs):        """        插入数据        :param creator: user        :param kwargs: cls.field        :param stepId: stepId        :return: none        """        try:            async with async_session() as session:                async with session.begin():                    kwargs["creator"] = creator.id                    kwargs["creatorName"] = creator.username                    kwargs["stepId"] = stepId                    # kwargs["sql_str"] = kwargs["sql_str"][::-1]                    await super().save_no_session(session=session, **kwargs)                    await UICaseStepMapper.update_by_id(                        session=session, updateUser=creator,                        **{"id": stepId, "has_sql": 1})        except Exception as e:            raise e    @classmethod    async def deleted(cls, user: User, uid: str):        """        通过uid删除        :param uid:        :param user        """        try:            async with async_session() as session:                async with session.begin():                    targe = await UICaseStepSQLMapper.get_by_uid(session=session, uid=uid)                    stepId = targe.stepId                    await session.delete(targe)                    await UICaseStepMapper.update_by_id(session=session, updateUser=user,                                                        **{"id": stepId, "has_sql": 0})        except Exception as e:            raise eclass UICaseStepApiMapper(Mapper):    __model__ = UIStepAPIModel    @classmethod    async def copy_api(cls, session: AsyncSession, oldStepId: int, newStepId: int, cr: User):        try:            old_api = await cls.get_by(session, stepId=oldStepId)            if old_api:                new_api = old_api.copy_map                new_api['creator'] = cr.id                new_api['creatorName'] = cr.username                new_api['stepId'] = newStepId                log.info(new_api)                await cls.save_no_session(session, **new_api)        except Exception as e:            raise e    @classmethod    async def insert(cls: Type[T], creator: User, **kwargs):        """        插入数据        :param kwargs: cls.field        :param creator:User        :return: none        """        try:            async with async_session() as session:                async with session.begin():                    kwargs["creator"] = creator.id                    kwargs["creatorName"] = creator.username                    await super().save_no_session(session=session, **kwargs)                    stepId = kwargs.get("stepId")                    await UICaseStepMapper.update_by_id(session=session, updateUser=creator,                                                        **{"id": stepId, "has_api": 1})        except Exception as e:            raise e    @classmethod    async def deleted(cls, user: User, uid: str):        """        通过uid删除        :param uid:        :param user:        """        try:            async with async_session() as session:                async with session.begin():                    targe = await UICaseStepApiMapper.get_by_uid(session=session, uid=uid)                    stepId = targe.stepId                    await session.delete(targe)                    await UICaseStepMapper.update_by_id(session=session, updateUser=user,                                                        **{"id": stepId, "has_api": 0})        except Exception as e:            raise e