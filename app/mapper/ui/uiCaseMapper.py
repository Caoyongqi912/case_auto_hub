#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : uiMapper# @Software: PyCharm# @Desc:from datetime import datetime, timefrom typing import List, Typefrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.model import async_sessionfrom sqlalchemy import or_, select, func, and_, insertfrom app.model.ui import UICaseModel, UICaseStepsModel, case_step_Table, UIStepAPIModel, UIStepSQLModel, UIStepGroupModelfrom app.model.base import CasePartfrom app.mapper import Mapper, Tfrom utils import logclass UICaseMapper(Mapper):    __model__ = UICaseModel    @classmethod    async def add_group_step(cls, caseId: int, groupIds: List[int]):        """        用例添加step 末尾顺序插入        关联group        :param caseId:        :param groupIds:        :return:        """        from app.mapper.ui.uiCaseStepGroupMapper import UICaseStepGroupMapper        try:            async with async_session() as session:                async with session.begin():                    case: UICaseModel = await cls.get_by_id(ident=caseId, session=session, desc="用例")                    new_steps: List[UICaseStepsModel] = []                    for id in groupIds:                        group: UIStepGroupModel = await UICaseStepGroupMapper.get_by_id(ident=id, session=session,                                                                                        desc='步骤组')                        _step = UICaseStepsModel(                            name=group.name,                            desc=group.desc,                            is_group=True,                            group_Id=id,                            creator=group.creator,                            creatorName=group.creatorName                        )                        new_steps.append(_step)                    session.add_all(new_steps)                    await session.flush()                    last_step_index = await cls.get_case_step_last_index(session, case.id)                    await session.execute(                        insert(case_step_Table).values(                            [                                {                                    "ui_case_id": case.id,                                    "ui_case_step_id": step.id,                                    "step_order": index                                }                                for index, step in enumerate(new_steps, start=last_step_index + 1)                            ]                        )                    )                    case.step_num += len(new_steps)                    await session.flush()        except Exception as e:            raise e    @classmethod    async def page_query(cls: Type[T], current: int, pageSize: int, **kwargs):        """        分页        :param current:        :param pageSize:        :param kwargs:        :return:        """        select_part_id = kwargs.pop('casePartId', None)        if not select_part_id:            return await super().page_query(current, pageSize, **kwargs)        try:            async with async_session() as session:                # 递归查询子项                casePart_base_query = select(CasePart.id).where(CasePart.id == select_part_id)                cte = casePart_base_query.cte(name='ChildRecords', recursive=True)                cte = cte.union_all(                    select(CasePart.id)                    .select_from(CasePart.__table__.join(cte, CasePart.parentID == cte.c.id))                )                cte_query = select(cte.c.id)                results = (await session.execute(cte_query)).scalars().all()                log.debug(results)                # 基础查询                base_query = select(cls.__model__).filter(                    cls.__model__.casePartId.in_(results)                )                conditions = await cls.search_conditions(**kwargs)                base_query = base_query.filter(and_(*conditions))                base_query = await cls.sorted_search(base_query, kwargs.pop("sort", None))                # 获取总数                total_query = select(func.count()).select_from(cls.__model__).filter(                    cls.__model__.casePartId.in_(results)                )                total_query = total_query.filter(and_(*conditions))                total = (await session.execute(total_query)).scalar()                # 分页查询                paginated_query = base_query.offset((current - 1) * pageSize).limit(pageSize)                data = (await session.execute(paginated_query)).scalars().all()                return await cls.map_page_data(data,                                               total,                                               pageSize,                                               current)        except Exception as e:            raise e    @classmethod    async def delete_by_uid(cls, uid: str):        """        删除用例            - 删除步骤（私有）            - 删除前置变量        :param uid:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    case = await cls.get_by_uid(uid, session)                    await session.delete(case)        except Exception as e:            await session.rollback()            raise e    @staticmethod    async def query_steps_by_caseId(caseId: int) -> List[UICaseStepsModel]:        """        查询用例步骤        :param caseId:        :return:        """        try:            async with async_session() as session:                sql = select(UICaseStepsModel).join(                    case_step_Table,                    case_step_Table.c.ui_case_step_id == UICaseStepsModel.id                ).where(                    case_step_Table.c.ui_case_id == caseId                ).order_by(                    case_step_Table.c.step_order                )                steps = await session.execute(sql)                return steps.scalars().all()        except Exception as e:            raise e    @staticmethod    async def count_case_by_date(projectId: int,                                 st: str, et: str):        """        日期查询        """        try:            async with async_session() as session:                # 将 st 和 et 转换为 datetime 对象（假设你的数据库使用的是 datetime 类型）                st = datetime.fromisoformat(st)                et = datetime.fromisoformat(et)                # 处理时间范围，包括整天的时间                start_of_day = datetime.combine(st, time.min)  # 今天的开始时间                end_of_day = datetime.combine(et, time.max)  # 今天的结束时间                log.debug(f"Querying from {start_of_day} to {end_of_day}")                # 查询所有根部件                caseParentParts_query = select(CasePart).where(and_(                    CasePart.projectID == projectId,                    CasePart.isRoot == 1                ))                exe = await session.execute(caseParentParts_query)                caseParentParts = exe.scalars().all()                # 获取所有根部件 ID                root_ids = [part.id for part in caseParentParts]                # 查询所有子部件                caseChildParts_query = select(CasePart).where(CasePart.rootID.in_(root_ids))                exe = await session.execute(caseChildParts_query)                caseChildParts = exe.scalars().all()                # 合并根部件和子部件的 ID                all_case_part_ids = root_ids + [part.id for part in caseChildParts]                # 统计时间范围内的案例数量                case_counts_query = select(func.count()).where(                    UICaseModel.casePartId.in_(all_case_part_ids),                    UICaseModel.create_time.between(start_of_day, end_of_day)                )                exe = await session.execute(case_counts_query)                total_count = exe.scalar()                # 构建每个部件的计数                data = []                for part in caseParentParts:                    # 计算当前根部件下的所有子部件和本身的计数                    count_query = select(func.count()).where(                        or_(                            UICaseModel.casePartId == part.id,                            UICaseModel.casePartId.in_(                                [childPart.id for childPart in caseChildParts if childPart.rootID == part.id])                        ),                        UICaseModel.create_time.between(start_of_day, end_of_day)                    )                    exe = await session.execute(count_query)                    case_count = exe.scalar()                    p = {                        "partName": part.partName,                        "caseCount": case_count if case_count else 0                    }                    data.append(p)                result = {                    "total": total_count,                    "data": data                }                return result        except Exception as e:            raise e    @staticmethod    async def query_case_by_date(begin_date: str, end_date: str) -> List[UICaseStepsModel]:        """        日期查询        """        try:            async with async_session() as session:                sql = select(UICaseModel).where(                    UICaseModel.create_time.between(begin_date, end_date)                )                cases = await session.execute(sql)                return cases.scalars().all()        except Exception as e:            raise e    @staticmethod    async def query_case_part(casePartId: int) -> List[UICaseModel]:        """        通过case part 查询case 同时包含子夫模块        :param casePartId:        :return:        """        try:            async with async_session() as session:                # 查询casePart模块与子模块                sql = select(UICaseModel).join(                    CasePart,                    UICaseModel.casePartId == CasePart.id                ).where(                    or_(                        CasePart.id == casePartId,                        CasePart.parentID == casePartId                    )                )                exe = await session.execute(sql)                cases = exe.scalars().all()                return cases        except Exception as e:            raise e    @staticmethod    async def count_by_projectId(projectId: int):        try:            async with async_session() as session:                # 查询所有根部件                caseParentParts = select(CasePart).where(and_(                    CasePart.projectID == projectId,                    CasePart.isRoot == 1                ))                exe = await session.execute(caseParentParts)                caseParentParts = exe.scalars().all()                total = 0                data = []                for part in caseParentParts:                    # 查询当前根部件及其子部件下的所有测试用例数量                    sql = select(func.count()).where(                        or_(                            UICaseModel.casePartId == part.id,                            UICaseModel.casePartId.in_(                                select(CasePart.id).where(CasePart.rootID == part.id)                            )                        )                    )                    exe = await session.execute(sql)                    caseCounts = exe.scalar()                    total += caseCounts                    p = {                        "partName": part.partName,                        "caseCount": caseCounts if caseCounts else 0                    }                    data.append(p)            result = {                "total": total,                "data": data            }            return result        except Exception as e:            raise e    @staticmethod    async def get_case_step_last_index(session: AsyncSession, caseId: int) -> int:        """        get case_step_Table last step order by groupId        :param session:        :param caseId:        :return:        """        try:            # Construct the query to get the last step order            sql = (                select(case_step_Table.c.step_order)                .where(case_step_Table.c.ui_case_id == caseId)                .order_by(case_step_Table.c.step_order.desc())  # Order by step_order descending                .limit(1)  # Limit to the last step only            )            # Execute the query            result = await session.execute(sql)            last_step_order = result.scalar()  # Fetch the first (and only) result            return last_step_order or 0        except Exception as e:            raise eclass UICaseStepMapper(Mapper):    __model__ = UICaseStepsModel    @classmethod    async def query_steps_by_caseId(cls, caseId: int):        try:            async with async_session() as session:                sql = select(UICaseStepsModel).join(                    case_step_Table,                    case_step_Table.c.ui_case_step_id == UICaseStepsModel.id                ).where(                    case_step_Table.c.ui_case_id == caseId                ).order_by(case_step_Table.c.step_order)                exe = await session.execute(sql)                return exe.scalars().all()        except Exception as e:            raise e    @classmethod    async def add_common_step(cls, **kwargs):        """        添加UI公共步骤        :param kwargs:        :return:        """        try:            await super().insert(**kwargs)        except Exception as e:            raise e    @staticmethod    async def insert_association(caseId: int, stepId: int, step_order: int):        """        为copy脚本用的        :return:        """        try:            async with async_session() as session:                case_step = case_step_Table.insert().values(                    ui_case_id=caseId,                    ui_case_step_id=stepId,                    step_order=step_order                )                await session.execute(case_step)                await session.commit()        except Exception as e:            raise eclass UICaseStepSQLMapper(Mapper):    __model__ = UIStepSQLModel    @classmethod    async def insert(cls: Type[T], **kwargs):        """        插入数据        :param kwargs: cls.field        :return: none        """        try:            async with async_session() as session:                kwargs["sql_str"] = kwargs["sql_str"][::-1]                await super().insert(**kwargs)                stepId = kwargs.get("stepId")                await UICaseStepMapper.update_by_id(**{"id": stepId, "has_sql": 1})        except Exception as e:            raise e    @staticmethod    async def deleted(uid: str):        """        通过uid删除        :param uid:        """        try:            async with async_session() as session:                targe = await UICaseStepSQLMapper.get_by_uid(session=session, uid=uid)                stepId = targe.stepId                await session.delete(targe)                await session.commit()                await UICaseStepMapper.update_by_id(**{"id": stepId, "has_sql": 0})        except Exception as e:            raise e    @classmethod    async def update_by_uid(cls: Type[T], **kwargs):        kwargs["sql_str"] = kwargs["sql_str"][::-1]        return await super().update_by_uid(**kwargs)class UICaseStepApiMapper(Mapper):    __model__ = UIStepAPIModel    @classmethod    async def insert(cls: Type[T], **kwargs):        """        插入数据        :param kwargs: cls.field        :return: none        """        try:            async with async_session() as session:                await super().insert(**kwargs)                stepId = kwargs.get("stepId")                await UICaseStepMapper.update_by_id(**{"id": stepId, "has_api": 1})        except Exception as e:            raise e    @staticmethod    async def deleted(uid: str):        """        通过uid删除        :param uid:        """        try:            async with async_session() as session:                targe = await UICaseStepApiMapper.get_by_uid(session=session, uid=uid)                stepId = targe.stepId                await session.delete(targe)                await session.commit()                await UICaseStepMapper.update_by_id(**{"id": stepId, "has_api": 0})        except Exception as e:            raise e