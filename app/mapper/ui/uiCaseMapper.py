#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : uiMapper# @Software: PyCharm# @Desc:from datetime import datetime, timefrom typing import List, Typefrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.orm import deferfrom app.mapper.ui.uiCaseVariableMapper import UICaseVariableMapperfrom app.mapper.ui.uiSubStepMapper import SubStepMapperfrom app.model import async_sessionfrom sqlalchemy import or_, select, func, and_, insert, update, deletefrom app.model.ui import UICaseModel, UIStepAPIModel, UIStepSQLModel, \    UIStepGroupModel, case_step_association, UICaseStepsModel, SubStepModel, case_task_Tablefrom app.model.base import CasePart, Userfrom app.mapper import Mapper, Tfrom enums.CaseEnum import CaseLevel, CaseStatusfrom utils import logasync def insert_case_step_association(session: AsyncSession, caseId: int, stepId: int, step_order: int):    """    插入关联 case step    如果存在 返回 False，否则插入并返回 True    :param session: 异步会话对象    :param caseId: 关联的用例 ID    :param stepId: 关联的步骤 ID    :param step_order: 步骤顺序    :return: 是否成功插入    """    try:        # 检查是否存在相同的 case_id 和 step_id        result = await session.execute(            select(case_step_association).where(                and_(                    case_step_association.c.ui_case_id == caseId,                    case_step_association.c.ui_case_step_id == stepId                )            )        )        if result.scalar() is not None:            return False        await session.execute(case_step_association.insert().values(            ui_case_id=caseId,            ui_case_step_id=stepId,            step_order=step_order        ))        return True    except Exception as e:        raise easync def get_case_step_last_index(session: AsyncSession, caseId: int) -> int:    """    异步获取指定用例的最后一个步骤索引。    该函数查询数据库以找到给定用例ID的最大步骤顺序值，从而确定该用例的最后一个步骤索引。    参数:    - session: AsyncSession - 异步数据库会话对象，用于执行数据库查询。    - caseId: int - 用例ID，用于过滤与此用例关联的步骤。    返回:    - int - 用例的最后一个步骤索引。如果没有找到该用例的步骤，则返回0。    """    try:        sql = (            select(case_step_association.c.step_order)            .where(case_step_association.c.ui_case_id == caseId)            .order_by(case_step_association.c.step_order.desc())            .limit(1)  # Limit to the last step only        )        result = await session.execute(sql)        last_step_order = result.scalar()        return last_step_order or 0    except Exception as e:        raise eclass UICaseMapper(Mapper):    __model__ = UICaseModel    @classmethod    async def copy_case(cls, caseId: str, cr: User) -> UICaseModel:        """        复制用例        复制step subStep ..        复制关联        """        try:            async with async_session() as session:                async with session.begin():                    old_case = await cls.get_by_uid(caseId, session=session)                    old_steps = await cls.query_steps_by_caseId(old_case.id, session)                    new_case = old_case.copy_map                    new_case['title'] = f"{new_case['title']} (副本)"                    new_case['creator'] = cr.id                    new_case['creatorName'] = cr.username                    new_case['level'] = CaseLevel.getValue(new_case['level'])                    new_case['status'] = CaseStatus.getValue(new_case['status'])                    new_case = await cls.save_no_session(session, **new_case)                    await UICaseVariableMapper.copy_vars(old_case.id, new_case.id, session, cr)                    await UICaseStepMapper.copy_step_form_case(session, new_case.id, old_steps, cr)                    return new_case        except Exception as e:            raise e    @classmethod    async def add_group_step(cls, caseId: int, groupIds: List[int]):        """        用例添加step 末尾顺序插入        关联group        :param caseId:        :param groupIds:        :return:        """        from app.mapper.ui.uiCaseStepGroupMapper import UICaseStepGroupMapper        try:            async with async_session() as session:                async with session.begin():                    case: UICaseModel = await cls.get_by_id(ident=caseId, session=session, desc="用例")                    new_steps: List[UICaseStepsModel] = []                    for id in groupIds:                        group: UIStepGroupModel = await UICaseStepGroupMapper.get_by_id(ident=id, session=session,                                                                                        desc='步骤组')                        _step = UICaseStepsModel(                            name=group.name,                            desc=group.desc,                            is_group=True,                            group_Id=id,                            creator=group.creator,                            creatorName=group.creatorName                        )                        new_steps.append(_step)                    session.add_all(new_steps)                    await session.flush()                    last_step_index = await get_case_step_last_index(session, case.id)                    await session.execute(                        insert(case_step_association).values(                            [                                {                                    "ui_case_id": case.id,                                    "ui_case_step_id": step.id,                                    "step_order": index                                }                                for index, step in enumerate(new_steps, start=last_step_index + 1)                            ]                        )                    )                    case.step_num += len(new_steps)                    await session.flush()        except Exception as e:            raise e    @classmethod    async def page_query(cls: Type[T], current: int, pageSize: int, **kwargs):        """        分页        :param current:        :param pageSize:        :param kwargs:        :return:        """        select_part_id = kwargs.pop('case_part_id', None)        if not select_part_id:            return await super().page_query(current, pageSize, **kwargs)        try:            async with async_session() as session:                # 递归查询子项                casePart_base_query = select(CasePart.id).where(CasePart.id == select_part_id)                cte = casePart_base_query.cte(name='ChildRecords', recursive=True)                cte = cte.union_all(                    select(CasePart.id)                    .select_from(CasePart.__table__.join(cte, CasePart.parentID == cte.c.id))                )                cte_query = select(cte.c.id)                results = (await session.execute(cte_query)).scalars().all()                log.debug(results)                # 基础查询                base_query = select(cls.__model__).filter(                    cls.__model__.case_part_id.in_(results)                )                conditions = await cls.search_conditions(**kwargs)                base_query = base_query.filter(and_(*conditions))                base_query = await cls.sorted_search(base_query, kwargs.pop("sort", None))                # 获取总数                total_query = select(func.count()).select_from(cls.__model__).filter(                    cls.__model__.case_part_id.in_(results)                )                total_query = total_query.filter(and_(*conditions))                total = (await session.execute(total_query)).scalar()                # 分页查询                paginated_query = base_query.offset((current - 1) * pageSize).limit(pageSize)                data = (await session.execute(paginated_query)).scalars().all()                return await cls.map_page_data(data,                                               total,                                               pageSize,                                               current)        except Exception as e:            raise e    @staticmethod    async def query_steps_by_caseId(caseId: int, session: AsyncSession = None) -> List[UICaseStepsModel]:        """        查询用例步骤        :param caseId:        :param session:        :return:        """        sql = select(UICaseStepsModel).join(            case_step_association,            case_step_association.c.ui_case_step_id == UICaseStepsModel.id        ).where(            case_step_association.c.ui_case_id == caseId        ).order_by(            case_step_association.c.step_order        )        try:            if session:                steps = await session.execute(sql)                return steps.scalars().all()            else:                async with async_session() as session:                    steps = await session.execute(sql)                    return steps.scalars().all()        except Exception as e:            raise e    @staticmethod    async def count_case_by_date(projectId: int,                                 st: str, et: str):        """        日期查询        """        try:            async with async_session() as session:                # 将 st 和 et 转换为 datetime 对象（假设你的数据库使用的是 datetime 类型）                st = datetime.fromisoformat(st)                et = datetime.fromisoformat(et)                # 处理时间范围，包括整天的时间                start_of_day = datetime.combine(st, time.min)  # 今天的开始时间                end_of_day = datetime.combine(et, time.max)  # 今天的结束时间                log.debug(f"Querying from {start_of_day} to {end_of_day}")                # 查询所有根部件                caseParentParts_query = select(CasePart).where(and_(                    CasePart.projectID == projectId,                    CasePart.isRoot == 1                ))                exe = await session.execute(caseParentParts_query)                caseParentParts = exe.scalars().all()                # 获取所有根部件 ID                root_ids = [part.id for part in caseParentParts]                # 查询所有子部件                caseChildParts_query = select(CasePart).where(CasePart.rootID.in_(root_ids))                exe = await session.execute(caseChildParts_query)                caseChildParts = exe.scalars().all()                # 合并根部件和子部件的 ID                all_case_part_ids = root_ids + [part.id for part in caseChildParts]                # 统计时间范围内的案例数量                case_counts_query = select(func.count()).where(                    UICaseModel.case_part_id.in_(all_case_part_ids),                    UICaseModel.create_time.between(start_of_day, end_of_day)                )                exe = await session.execute(case_counts_query)                total_count = exe.scalar()                # 构建每个部件的计数                data = []                for part in caseParentParts:                    # 计算当前根部件下的所有子部件和本身的计数                    count_query = select(func.count()).where(                        or_(                            UICaseModel.case_part_id == part.id,                            UICaseModel.case_part_id.in_(                                [childPart.id for childPart in caseChildParts if childPart.rootID == part.id])                        ),                        UICaseModel.create_time.between(start_of_day, end_of_day)                    )                    exe = await session.execute(count_query)                    case_count = exe.scalar()                    p = {                        "partName": part.partName,                        "caseCount": case_count if case_count else 0                    }                    data.append(p)                result = {                    "total": total_count,                    "data": data                }                return result        except Exception as e:            raise e    @staticmethod    async def query_case_by_date(begin_date: str, end_date: str) -> List[UICaseStepsModel]:        """        日期查询        """        try:            async with async_session() as session:                sql = select(UICaseModel).where(                    UICaseModel.create_time.between(begin_date, end_date)                )                cases = await session.execute(sql)                return cases.scalars().all()        except Exception as e:            raise e    @staticmethod    async def query_case_part(case_part_id: int) -> List[UICaseModel]:        """        通过case part 查询case 同时包含子夫模块        :param case_part_id:        :return:        """        try:            async with async_session() as session:                # 查询casePart模块与子模块                sql = select(UICaseModel).join(                    CasePart,                    UICaseModel.case_part_id == CasePart.id                ).where(                    or_(                        CasePart.id == case_part_id,                        CasePart.parentID == case_part_id                    )                )                exe = await session.execute(sql)                cases = exe.scalars().all()                return cases        except Exception as e:            raise e    @staticmethod    async def count_by_projectId(projectId: int):        try:            async with async_session() as session:                # 查询所有根部件                caseParentParts = select(CasePart).where(and_(                    CasePart.projectID == projectId,                    CasePart.isRoot == 1                ))                exe = await session.execute(caseParentParts)                caseParentParts = exe.scalars().all()                total = 0                data = []                for part in caseParentParts:                    # 查询当前根部件及其子部件下的所有测试用例数量                    sql = select(func.count()).where(                        or_(                            UICaseModel.case_part_id == part.id,                            UICaseModel.case_part_id.in_(                                select(CasePart.id).where(CasePart.rootID == part.id)                            )                        )                    )                    exe = await session.execute(sql)                    caseCounts = exe.scalar()                    total += caseCounts                    p = {                        "partName": part.partName,                        "caseCount": caseCounts if caseCounts else 0                    }                    data.append(p)            result = {                "total": total,                "data": data            }            return result        except Exception as e:            raise e    @classmethod    async def add_step(cls, case_id: int, **kwargs):        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    case = await cls.get_by_id(ident=case_id, session=session)                    kwargs['creator'] = case.creator                    kwargs['creatorName'] = case.creatorName                    # 插入 step                    step = await UICaseStepMapper.save_no_session(session=session,                                                                  **kwargs)                    last_step_order = await get_case_step_last_index(session, case_id)                    if await insert_case_step_association(session, case.id, step.id, last_step_order + 1):                        case.step_num += 1        except Exception as e:            raise e    @classmethod    async def add_choices(cls, caseId: int, choices: List[int]):        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    case = await cls.get_by_id(ident=caseId, session=session)                    last_step_index = await get_case_step_last_index(session, caseId)                    for index, stepId in enumerate(choices, start=last_step_index + 1):                        if await insert_case_step_association(session, caseId, stepId, index):                            case.step_num += 1        except Exception as e:            raise e    @classmethod    async def add_copy(cls, caseId: int, choices: List[int]):        """        对选择进行复制后关联        """        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    case = await cls.get_by_id(ident=caseId, session=session)                    last_step_index = await get_case_step_last_index(session, caseId)                    # 查询step                    for stepId in choices:                        step: UICaseStepsModel = await UICaseStepMapper.get_by_id(ident=stepId, session=session)                        # 插入 step                        temp_step = step.copy_map                        temp_step['creator'] = case.creator                        temp_step['creatorName'] = case.creatorName                        temp_step['is_common_step'] = False                        new_step = await UICaseStepMapper.save_no_session(session=session,                                                                          **temp_step)                        if await insert_case_step_association(session, case.id, new_step.id, last_step_index + 1):                            case.step_num += 1        except Exception as e:            raise eclass UICaseStepMapper(Mapper):    __model__ = UICaseStepsModel    @classmethod    async def query_steps_by_caseId(cls, caseId: int):        try:            async with async_session() as session:                sql = select(UICaseStepsModel).join(                    case_step_association,                    case_step_association.c.ui_case_step_id == UICaseStepsModel.id                ).where(                    case_step_association.c.ui_case_id == caseId                ).order_by(case_step_association.c.step_order)                exe = await session.execute(sql)                return exe.scalars().all()        except Exception as e:            raise e    @classmethod    async def remove_step(cls, stepId: int, caseId: int = None):        """        如果 caseId 不为空 判断是否 是公共 如果是删除关联表        如果不是删除步骤、删除关联        如果为空        直接删除        :param stepId:        :param caseId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    # 查询步骤                    step = await cls.get_by_id(ident=stepId, session=session)                    if caseId is not None:                        case = await UICaseMapper.get_by_id(ident=caseId, session=session)                        case.step_num -= 1                        # 删除关联表                        await session.execute(                            case_step_association.delete().where(                                and_(                                    case_step_association.c.ui_case_step_id == stepId,                                    case_step_association.c.ui_case_id == caseId                                )                            )                        )                        if not step.is_common_step:                            # 删除步骤                            await session.delete(step)                    else:                        # 直接删除步骤                        await session.delete(step)        except Exception as e:            raise e    @classmethod    async def reorder_step(cls, caseId: int, stepIds: [int]):        """        根据steps 重新排序        """        try:            async with async_session() as session:                async with session.begin():                    for index, stepId in enumerate(stepIds, start=1):                        await session.execute(                            case_step_association.update().where(                                and_(                                    case_step_association.c.ui_case_step_id == stepId,                                    case_step_association.c.ui_case_id == caseId                                )                            ).values(                                step_order=index                            )                        )        except Exception as e:            raise e    @staticmethod    async def copy_step_form_case(session: AsyncSession, caseId: int, oldSteps: List[UICaseStepsModel], cr: User):        """        复制step        复制api 、 sql、condition        插入关联表        """        try:            for index, step in enumerate(oldSteps, start=1):                # 插入 step                new_step = step.copy_map                new_step['creator'] = cr.id                new_step['creatorName'] = cr.username                new_step = await UICaseStepMapper.save_no_session(session=session,                                                                  **new_step)                if new_step.has_sql:                    await UICaseStepSQLMapper.copy_sql(session, step.id, new_step.id, cr)                if new_step.has_api:                    await UICaseStepApiMapper.copy_api(session, step.id, new_step.id, cr)                if new_step.has_condition:                    await SubStepMapper.copy_sub(session, step.id, new_step.id, cr)                await insert_case_step_association(session, caseId, new_step.id, index)        except Exception as e:            raise e    @classmethod    async def copy_step(cls, caseId: int, stepId: int):        try:            async with async_session() as session:                async with session.begin():                    # 查询步骤                    step: UICaseStepsModel = await cls.get_by_id(ident=stepId, session=session)                    # 查询case                    case = await UICaseMapper.get_by_id(ident=caseId, session=session)                    case.step_num += 1                    # 插入 step                    temp_step = step.copy_map                    temp_step['name'] = f"{temp_step['name']} (副本)"                    temp_step['creator'] = case.creator                    temp_step['creatorName'] = case.creatorName                    temp_step['is_common_step'] = False                    temp_step['has_api'] = False                    temp_step['has_sql'] = False                    temp_step['has_condition'] = False                    temp_step['condition'] = None                    new_step = await cls.save_no_session(session=session,                                                         **temp_step)                    # last_step_order                    last_step_order = await get_case_step_last_index(session, caseId)                    await insert_case_step_association(session, case.id, new_step.id, last_step_order + 1)                    log.debug(f"last_step_order = {last_step_order}")        except Exception as e:            raise e    @classmethod    async def add_condition(cls, stepId: int, key: str, value: str, operator: int):        """        添加条件        :param stepId:        :param key:        :param value:        :param operator:        :return:        """        try:            async with async_session() as session:                data = {"key": key, "value": value, "operator": operator}                step = await cls.get_by_id(ident=stepId, session=session)                step.has_condition = True                step.condition = data                await session.commit()                await session.close()        except Exception as e:            raise e    @classmethod    async def update_condition(cls, stepId: int, key: str, value: str, operator: int):        """        跟新条件        :param stepId:        :param key:        :param value:        :param operator:        :return:        """        try:            async with async_session() as session:                data = {"key": key, "value": value, "operator": operator}                step = await cls.get_by_id(ident=stepId, session=session)                step.has_condition = True                step.condition = data                await session.commit()                await session.close()        except Exception as e:            raise e    @classmethod    async def remove_condition(cls, stepId: int):        """        添加条件        :param stepId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    # 跟新step                    await session.execute(                        update(cls.__model__).where(                            cls.__model__.id == stepId                        ).values(                            has_condition=False,                            condition=None                        )                    )                    await session.execute(                        delete(SubStepModel).where(                            SubStepModel.stepId == stepId                        )                    )        except Exception as e:            raise eclass UICaseStepSQLMapper(Mapper):    __model__ = UIStepSQLModel    @classmethod    async def copy_sql(cls, session: AsyncSession, oldStepId: int, newStepId: int, cr: User):        try:            old_sql = await cls.get_by(session, stepId=oldStepId)            if old_sql:                new_sql = old_sql.copy_map                new_sql['creator'] = cr.id                new_sql['creatorName'] = cr.username                new_sql['stepId'] = newStepId                await cls.save_no_session(session, **new_sql)        except Exception as e:            raise e    @classmethod    async def insert(cls: Type[T], creator: User, stepId: int, **kwargs):        """        插入数据        :param creator: user        :param kwargs: cls.field        :param stepId: stepId        :return: none        """        try:            async with async_session() as session:                async with session.begin():                    kwargs["creator"] = creator.id                    kwargs["creatorName"] = creator.username                    kwargs["stepId"] = stepId                    # kwargs["sql_str"] = kwargs["sql_str"][::-1]                    await super().save_no_session(session=session, **kwargs)                    await UICaseStepMapper.update_by_id(                        session=session, updateUser=creator,                        **{"id": stepId, "has_sql": 1})        except Exception as e:            raise e    @classmethod    async def deleted(cls, user: User, uid: str):        """        通过uid删除        :param uid:        :param user        """        try:            async with async_session() as session:                async with session.begin():                    targe = await UICaseStepSQLMapper.get_by_uid(session=session, uid=uid)                    stepId = targe.stepId                    await session.delete(targe)                    await UICaseStepMapper.update_by_id(session=session, updateUser=user,                                                        **{"id": stepId, "has_sql": 0})        except Exception as e:            raise eclass UICaseStepApiMapper(Mapper):    __model__ = UIStepAPIModel    @classmethod    async def copy_api(cls, session: AsyncSession, oldStepId: int, newStepId: int, cr: User):        try:            old_api = await cls.get_by(session, stepId=oldStepId)            if old_api:                new_api = old_api.copy_map                new_api['creator'] = cr.id                new_api['creatorName'] = cr.username                new_api['stepId'] = newStepId                log.info(new_api)                await cls.save_no_session(session, **new_api)        except Exception as e:            raise e    @classmethod    async def insert(cls: Type[T], creator: User, **kwargs):        """        插入数据        :param kwargs: cls.field        :param creator:User        :return: none        """        try:            async with async_session() as session:                async with session.begin():                    kwargs["creator"] = creator.id                    kwargs["creatorName"] = creator.username                    await super().save_no_session(session=session, **kwargs)                    stepId = kwargs.get("stepId")                    await UICaseStepMapper.update_by_id(session=session, updateUser=creator,                                                        **{"id": stepId, "has_api": 1})        except Exception as e:            raise e    @classmethod    async def deleted(cls, user: User, uid: str):        """        通过uid删除        :param uid:        :param user:        """        try:            async with async_session() as session:                async with session.begin():                    targe = await UICaseStepApiMapper.get_by_uid(session=session, uid=uid)                    stepId = targe.stepId                    await session.delete(targe)                    await UICaseStepMapper.update_by_id(session=session, updateUser=user,                                                        **{"id": stepId, "has_api": 0})        except Exception as e:            raise e