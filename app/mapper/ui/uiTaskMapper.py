#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : uiTaskMapper# @Software: PyCharm# @Desc:from typing import Listfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.sql.functions import countfrom app.model import async_sessionfrom sqlalchemy import select, update, and_, insert, delete, bindparamfrom app.model.ui import UICaseModel, UITaskModel, case_task_Tablefrom app.mapper import Mapperfrom enums.CaseEnum import Statusfrom utils import MyLogurulog = MyLoguru().get_logger()async def reorder_case(session: AsyncSession, task_id: int):    try:        # 查询已有关联的用例        stmt = (            select(UICaseModel)            .join(case_task_Table, case_task_Table.c.ui_case_id == UICaseModel.id)            .where(case_task_Table.c.ui_task_id == task_id)            .order_by(case_task_Table.c.case_order)        )        result = await session.execute(stmt)        cases = result.scalars().all()        # 如果没有用例，直接返回        if not cases:            return        # 准备批量更新数据        updates = [            {                "_ui_case_id": case.id,                "_ui_task_id": task_id,                "_case_order": index            }            for index, case in enumerate(cases, start=1)        ]        # 批量更新 case_order        update_stmt = (            update(case_task_Table)            .where(                and_(                    case_task_Table.c.ui_case_id == bindparam('_ui_case_id'),                    case_task_Table.c.ui_task_id == bindparam('_ui_task_id')                )            )            .values(case_order=bindparam('_case_order'))        )        await session.execute(update_stmt, updates)    except Exception as e:        # 在实际应用中，建议记录日志并重新抛出异常或处理异常        raise eclass UITaskMapper(Mapper):    __model__ = UITaskModel    @classmethod    async def query_case(cls, taskId: int) -> List[UICaseModel]:        """        查询用例        :param taskId: 任务id        :return:        """        try:            async with async_session() as session:                cases = await session.scalars(                    select(UICaseModel).join(                        case_task_Table,                        case_task_Table.c.ui_case_id == UICaseModel.id                    ).where(                        case_task_Table.c.ui_task_id == taskId                    ).order_by(                        case_task_Table.c.case_order                    )                )                return cases.all()        except Exception as e:            raise e    @classmethod    async def association_cases(cls, taskId: int, caseIdList: list[int]):        """        添加用例到task        :param taskId:        :param caseIdList:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    task = await cls.get_by_id(ident=taskId, session=session)                    # 检查现有的 UI Case IDs                    existing_cases = await session.execute(select(case_task_Table.c.ui_case_id).where(                        case_task_Table.c.ui_task_id == taskId                    ))                    existing_case_ids = {row[0] for row in existing_cases}                    last_case_index = await UITaskMapper.get_case_last_index(session=session, taskId=taskId)                    # 批量插入用例                    new_cases = [                        {                            'ui_task_id': taskId,                            'ui_case_id': caseId,                            'case_order': index                        }                        for index, caseId in enumerate(caseIdList, start=last_case_index + 1)                        if caseId not in existing_case_ids                    ]                    if new_cases:                        result = await session.execute(insert(case_task_Table).values(new_cases))                        task.ui_case_num += result.rowcount  # 更新已添加的用例数量        except Exception as e:            raise e    @classmethod    async def remove_association_case(cls, taskId: int, caseId: int):        """        移除用例        重新计算数量        :param taskId:        :param caseId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    task: UITaskModel = await cls.get_by_id(ident=taskId, session=session)                    # 删除关联                    await session.execute(delete(case_task_Table).where(                        and_(                            case_task_Table.c.ui_task_id == taskId,                            case_task_Table.c.ui_case_id == caseId                        )                    ))                    # 重新排序                    await reorder_case(session=session, task_id=taskId)                    # 更新用例数量                    data = await session.execute(                        select(count('*')).where(case_task_Table.c.ui_task_id == taskId)                    )                    task.ui_case_num = data.scalar()        except Exception as e:            raise e    @classmethod    async def reorder_association_case(cls, taskId: int, caseIdList: list[int]):        try:            async with async_session() as session:                for index, caseId in enumerate(caseIdList, start=1):                    await session.execute(case_task_Table.update().where(                        (case_task_Table.c.ui_case_id == caseId) &                        (case_task_Table.c.ui_task_id == taskId)                    ).values(case_order=index))                await session.commit()        except Exception as e:            raise e    @staticmethod    async def query_cases_by_task_id(taskId: int):        try:            async with async_session() as session:                sql = select(UICaseModel).join(                    case_task_Table,                    case_task_Table.c.ui_case_id == UICaseModel.id                ).where(                    case_task_Table.c.ui_task_id == taskId                ).order_by(case_task_Table.c.case_order)                cases = await session.execute(sql)                return cases.scalars().all()        except Exception as e:            raise e    @staticmethod    async def set_task_status(taskId: int, status: Status):        """        task 设置运行状态        :param taskId:        :param status: RUNNING WAIT        :return:        """        try:            async with async_session() as session:                async with session.begin():                    await session.execute(update(UITaskModel).where(UITaskModel.id == taskId).values(status=status))        except Exception as e:            raise e    @staticmethod    async def get_case_last_index(session: AsyncSession, taskId: int) -> int:        try:            sql = (                select(case_task_Table.c.case_order).where(                    case_task_Table.c.ui_task_id == taskId                ).order_by(case_task_Table.c.case_order.desc()).limit(1)            )            result = await session.execute(sql)            last_step_order = result.scalar()  # Fetch the first (and only) result            return last_step_order or 0        except Exception as e:            raise e    @classmethod    async def query_auto_task(cls):        try:            async with async_session() as session:                stmt = select(UITaskModel).where(                    UITaskModel.is_auto == True                )                data =  await session.scalars(stmt)                return data.all()        except Exception as e:            raise e