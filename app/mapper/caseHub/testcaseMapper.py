#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/8/27# @Author : cyq# @File : testcaseMapper# @Software: PyCharm# @Desc:from typing import List, Dict, Anyfrom sqlalchemy import select, insertfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper.caseHub.requirementMapper import RequirementMapperfrom app.mapper import Mapper, set_creatorfrom app.model import async_sessionfrom app.model.base import Userfrom app.model.caseHub.caseHUB import TestCase, TestCaseStep, Requirement, CaseStepDynamicfrom app.model.caseHub.association import RequirementCaseAssociationasync def get_last_index(session: AsyncSession, caseId: int) -> int:    try:        sql = (            select(RequirementCaseAssociation.order).where(                RequirementCaseAssociation.case_id == caseId            ).order_by(RequirementCaseAssociation.order.desc()).limit(1)        )        result = await session.execute(sql)        last_step_order = result.scalar()        return last_step_order or 0    except Exception as e:        raise eclass TestCaseMapper(Mapper):    __model__ = TestCase    @classmethod    async def query_by_req(cls, requirementId: int):        try:            async with async_session() as session:                stmt = select(TestCase).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ).order_by(RequirementCaseAssociation.order.desc())                cases = await session.scalars(stmt)                return cases.all()        except Exception as e:            raise e    @classmethod    async def save_case(cls, cr: User, **kwargs):        """        存用例 & 用例步骤        写日志        关联需求判断        """        reqId = kwargs.pop("requirementId", None)        case_sub_steps = kwargs.pop("case_sub_steps", [])        kwargs = await set_creator(cr, **kwargs)        try:            async with async_session() as session:                async with session.begin():                    case: TestCase = await cls.save_no_session(session, **kwargs)                    if case_sub_steps:                        await TestCaseStepMapper.save_steps(caseId=case.id, steps=case_sub_steps, session=session)                    if reqId:                        last_step_index = await get_last_index(session, case.id)                        await session.execute((insert(RequirementCaseAssociation).values(                            dict(                                requirement_id=reqId,                                case_id=case.id,                                order=last_step_index + 1                            )                        )))                        req = await RequirementMapper.get_by_id(ident=reqId, session=session)                        req.case_number += 1                    await CaseDynamicMapper.new_dynamic(                        cr=cr,                        case=case,                        session=session                    )                    return case        except Exception as e:            raise eclass TestCaseStepMapper(Mapper):    __model__ = TestCaseStep    @classmethod    async def save_steps(cls, caseId: int, steps: List[Dict[str, Any]], session: AsyncSession):        try:            for index, step in enumerate(steps):                step["test_case_id"] = caseId                step["order"] = index                await cls.save_no_session(session=session, **step)        except Exception as e:            raise eclass CaseDynamicMapper(Mapper):    __model__ = CaseStepDynamic    @classmethod    async def new_dynamic(cls, cr: User, case: TestCase, session: AsyncSession):        """        首次创建        """        dynamicInfo = dict(            description=f"{cr.username} 创建了测试用例。 {case.case_name}",            test_case_id=case.id,            creator=cr.id,            creatorName=cr.username        )        await cls.save_no_session(session=session, **dynamicInfo)