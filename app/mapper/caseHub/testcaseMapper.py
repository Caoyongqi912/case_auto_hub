#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/8/27# @Author : cyq# @File : testcaseMapper# @Software: PyCharm# @Desc:from typing import List, Dict, Anyfrom sqlalchemy import select, insertfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper.caseHub.requirementMapper import RequirementMapperfrom app.mapper import Mapper, set_creatorfrom app.model import async_sessionfrom app.model.base import Userfrom app.model.caseHub.caseHUB import TestCase, TestCaseStep, Requirement, CaseStepDynamicfrom app.model.caseHub.association import RequirementCaseAssociationfrom utils import logasync def get_last_index(session: AsyncSession, caseId: int) -> int:    try:        sql = (            select(RequirementCaseAssociation.order).where(                RequirementCaseAssociation.case_id == caseId            ).order_by(RequirementCaseAssociation.order.desc()).limit(1)        )        result = await session.execute(sql)        last_step_order = result.scalar()        return last_step_order or 0    except Exception as e:        raise eclass TestCaseMapper(Mapper):    __model__ = TestCase    @classmethod    async def query_by_req(cls, requirementId: int):        try:            async with async_session() as session:                stmt = select(TestCase).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ).order_by(RequirementCaseAssociation.order.desc())                cases = await session.scalars(stmt)                return cases.all()        except Exception as e:            raise e    @classmethod    async def save_case(cls, cr: User, **kwargs):        """        存用例 & 用例步骤        写日志        关联需求判断        """        reqId = kwargs.pop("requirementId", None)        case_sub_steps = kwargs.pop("case_sub_steps", [])        kwargs = await set_creator(cr, **kwargs)        try:            async with async_session() as session:                async with session.begin():                    case: TestCase = await cls.save_no_session(session, **kwargs)                    if case_sub_steps:                        await TestCaseStepMapper.save_steps(caseId=case.id, steps=case_sub_steps, session=session)                    if reqId:                        last_step_index = await get_last_index(session, case.id)                        await session.execute((insert(RequirementCaseAssociation).values(                            dict(                                requirement_id=reqId,                                case_id=case.id,                                order=last_step_index + 1                            )                        )))                        req = await RequirementMapper.get_by_id(ident=reqId, session=session)                        req.case_number += 1                    await CaseDynamicMapper.new_dynamic(                        cr=cr,                        case=case,                        session=session                    )                    return case        except Exception as e:            raise e    @classmethod    async def update_case(cls, ur: User, **kwargs):        """        用鳄梨更新        """        log.info(f"kwargs = {kwargs}")        try:            async with async_session() as session:                async with session.begin():                    case = await cls.get_by_id(ident=kwargs.get("id"), session=session)                    old_case = case.map                    new_case = await cls.update_cls(case, session, **kwargs)                    await CaseDynamicMapper.update_dynamic(                        cr=ur,                        case_id=case.id,                        old_case=old_case,                        new_case=new_case.map,                        session=session                    )        except Exception as e:            raise e    @classmethod    async def query_sub_steps(cls, case_id: int):        try:            async with async_session() as session:                steps = await session.scalars(select(TestCaseStep).where(                    TestCaseStep.test_case_id == case_id                ).order_by(TestCaseStep.order))                return steps.all()        except Exception as e:            raise e    @classmethod    async def set_case_steps(cls, test_case_id: int, case_sub_steps: List[Dict[str, Any]], user: User):        """        更新与新增 步骤        """        try:            async with async_session() as session:                async with session.begin():                    for index, step in enumerate(case_sub_steps):                        # 已存在的步骤                        if step.get("id"):                            exists_step: TestCaseStep = await TestCaseStepMapper.get_by_id(session=session,                                                                                           ident=step.get("id"))                            exists_step.order = index                            exists_step.test_case_id = test_case_id                            await TestCaseStepMapper.update_cls(exists_step, session, **step)                        else:                            step['test_case_id'] = test_case_id                            step["order"] = index                            await TestCaseStepMapper.save_no_session(session=session, **step)        except Exception as e:            raise eclass TestCaseStepMapper(Mapper):    __model__ = TestCaseStep    @classmethod    async def save_steps(cls, caseId: int, steps: List[Dict[str, Any]], session: AsyncSession):        try:            for index, step in enumerate(steps):                step["test_case_id"] = caseId                step["order"] = index                await cls.save_no_session(session=session, **step)        except Exception as e:            raise eclass CaseDynamicMapper(Mapper):    __model__ = CaseStepDynamic    @classmethod    async def new_dynamic(cls, cr: User, case: TestCase, session: AsyncSession):        """        首次创建动态写入        """        dynamicInfo = dict(            description=f"{cr.username} 创建了测试用例。 {case.case_name}",            test_case_id=case.id,            creator=cr.id,            creatorName=cr.username        )        await cls.save_no_session(session=session, **dynamicInfo)    @classmethod    async def update_dynamic(cls, cr: User, case_id: int, old_case: Dict[str, Any], new_case: Dict[str, Any],                             session: AsyncSession):        """        更新用例        """        diff_info = diff_dict(old_case, new_case)        if not diff_info:            return        updateInfo = f"{cr.username} 更新了测试用例 :{diff_info} "        dynamic_obj = CaseStepDynamic(            description=updateInfo,            test_case_id=case_id,            creator=cr.id,            creatorName=cr.username        )        session.add(dynamic_obj)        await session.flush()def diff_dict(old_case: Dict[str, Any], new_case: Dict[str, Any]) -> str:    """比较两个字典的差异，生成变更描述列表"""    # 配置常量    IGNORE_KEYS = {"id", "uid", "create_time", "update_time", "creator", "creatorName", "updater", "updaterName"}    KEY_MAP = {        "case_name": "用例名称",        "case_level": "用例等级",        "case_type": "用例类型",        "case_tag": "用例标签",        "case_setup": "前置条件",        "case_status": "用例状态",        "case_mark": "用例描述",        "is_review": "是否审核",    }    VALUE_MAPPINGS = {        "case_type": {            1: "冒烟",            2: "普通"        },        "is_review": {            True: "已评审",            False: "未评审"        }    }    diff_args = []    # 检查所有可能变更的键    all_keys = set(old_case.keys()) | set(new_case.keys())    relevant_keys = all_keys - IGNORE_KEYS    for key in relevant_keys:        old_value = old_case.get(key)        new_value = new_case.get(key)        # 跳过未变化的字段        if old_value == new_value:            continue        # 获取字段显示名称        field_name = KEY_MAP.get(key, key)        # 转换值显示        old_display = _transform_value(key, old_value)        new_display = _transform_value(key, new_value)        # 生成变更描述        if old_value is None:            diff_args.append(f"{field_name} 新增 {new_display}")        elif new_value is None:            diff_args.append(f"{field_name} 从 {old_display} 变更为 空")        else:            diff_args.append(f"{field_name} 从 {old_display} 变更为 {new_display}")    return "\n".join(diff_args)def _transform_value(field_key: str, value: Any) -> str:    """根据字段类型转换值的显示格式"""    if value is None:        return "空"    # 特定字段的值映射    VALUE_MAPPINGS = {        "case_type": {            1: "冒烟",            2: "普通"        },        "is_review": {            True: "已评审",            False: "未评审"        }    }    # 应用值映射    if field_key in VALUE_MAPPINGS and value in VALUE_MAPPINGS[field_key]:        return VALUE_MAPPINGS[field_key][value]    # 处理列表类型（如标签）    if isinstance(value, list):        return "、".join(str(v) for v in value) if value else "空"    # 处理布尔值    if isinstance(value, bool):        return "是" if value else "否"    return str(value)