#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/8/27# @Author : cyq# @File : testcaseMapper# @Software: PyCharm# @Desc:from typing import List, Dict, Any, Optional, Sequencefrom sqlalchemy import select, insert, update, and_, case, deletefrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper.caseHub.requirementMapper import RequirementMapperfrom app.mapper import Mapper, set_creatorfrom app.model import async_sessionfrom app.model.base import Userfrom app.model.caseHub.caseHUB import TestCase, TestCaseStep, CaseStepDynamicfrom app.model.caseHub.association import RequirementCaseAssociationfrom utils import logasync def get_last_index(session: AsyncSession, caseId: int) -> int:    try:        sql = (            select(RequirementCaseAssociation.order).where(                RequirementCaseAssociation.case_id == caseId            ).order_by(RequirementCaseAssociation.order.desc()).limit(1)        )        result = await session.execute(sql)        last_step_order = result.scalar()        return last_step_order or 0    except Exception as e:        raise eclass TestCaseMapper(Mapper):    __model__ = TestCase    @classmethod    async def remove_case(cls, caseId: int, requirementId: Optional[int]):        """        删除用例        requirementId ？ requirementId.cas_number -=1        """        try:            async with async_session() as session:                if requirementId:                    req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                    if req.case_number > 0:                        req.case_number -= 1                await session.execute(                    delete(cls.__model__).where(cls.__model__.id == caseId)                )                await session.commit()        except Exception as e:            raise e    @classmethod    async def query_by_req(cls, requirementId: int):        """        需求查询用例        """        try:            async with async_session() as session:                cases = await session.scalars(select(TestCase).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ).order_by(RequirementCaseAssociation.order))                return cases.all()        except Exception as e:            raise e    @classmethod    async def query_case_by_field(cls, requirementId: int, **kwargs):        """        过滤用例        """        try:            async with async_session() as session:                conditions = await cls.search_conditions(**kwargs)                cases = await session.scalars(select(TestCase).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ).where(                    and_(                        *conditions                    )                ).order_by(RequirementCaseAssociation.order))                return cases.all()        except Exception as e:            raise e    @classmethod    async def query_tags(cls, requirementId: int):        try:            async with async_session() as session:                tags = await session.scalars(select(TestCase.case_tag).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ))                result = tags.all()                return set(result)        except Exception as e:            raise e    @classmethod    async def save_case(cls, cr: User, **kwargs):        """        存用例 & 用例步骤        写日志        关联需求判断        """        reqId = kwargs.pop("requirementId", None)        case_sub_steps = kwargs.pop("case_sub_steps", [])        kwargs = await set_creator(cr, **kwargs)        try:            async with async_session() as session:                async with session.begin():                    case: TestCase = await cls.save_no_session(session, **kwargs)                    if case_sub_steps:                        await TestCaseStepMapper.save_steps(caseId=case.id, steps=case_sub_steps, session=session)                    if reqId is not None:                        last_step_index = await get_last_index(session, case.id)                        await session.execute((insert(RequirementCaseAssociation).values(                            dict(                                requirement_id=reqId,                                case_id=case.id,                                order=last_step_index + 1                            )                        )))                        req = await RequirementMapper.get_by_id(ident=reqId, session=session)                        req.case_number += 1                    await CaseDynamicMapper.new_dynamic(                        cr=cr,                        case=case,                        session=session                    )                    return case        except Exception as e:            raise e    @classmethod    async def update_case(cls, ur: User, **kwargs):        """        用鳄梨更新        """        log.info(f"kwargs = {kwargs}")        try:            async with async_session() as session:                async with session.begin():                    case = await cls.get_by_id(ident=kwargs.get("id"), session=session)                    old_case = case.map                    new_case = await cls.update_cls(case, session, **kwargs)                    await CaseDynamicMapper.update_dynamic(                        cr=ur,                        case_id=case.id,                        old_case=old_case,                        new_case=new_case.map,                        session=session                    )        except Exception as e:            raise e    @classmethod    async def query_sub_steps(cls, case_id: int):        try:            async with async_session() as session:                steps = await session.scalars(select(TestCaseStep).where(                    TestCaseStep.test_case_id == case_id                ).order_by(TestCaseStep.order))                return steps.all()        except Exception as e:            raise e    @classmethod    async def set_case_steps(cls, test_case_id: int, case_sub_steps: List[Dict[str, Any]], user: User):        """        更新与新增 步骤        """        try:            async with async_session() as session:                async with session.begin():                    for index, step in enumerate(case_sub_steps):                        # 已存在的步骤                        if step.get("id"):                            exists_step: TestCaseStep = await TestCaseStepMapper.get_by_id(session=session,                                                                                           ident=step.get("id"))                            exists_step.order = index                            exists_step.test_case_id = test_case_id                            await TestCaseStepMapper.update_cls(exists_step, session, **step)                        else:                            step['test_case_id'] = test_case_id                            step["order"] = index                            step['creator'] = user.id                            step['creatorName'] = user.username                            await TestCaseStepMapper.save_no_session(session=session, **step)        except Exception as e:            raise e    @classmethod    async def reorder_case(cls, requirementId: int, caseIds: List[int]):        """        需求下case 重新排序        """        try:            async with async_session() as session:                whens = {step_id: index for index, step_id in enumerate(caseIds, start=0)}                await session.execute(update(RequirementCaseAssociation).where(                    and_(                        RequirementCaseAssociation.requirement_id == requirementId,                        RequirementCaseAssociation.case_id.in_(caseIds)                    )                ).values(                    order=case(whens, value=RequirementCaseAssociation.case_id)                ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def copy_case(cls, caseId: int, user: User, requirementId: Optional[int]):        """        复制用例        """        try:            async with async_session() as session:                async with session.begin():                    target_case: TestCase = await cls.get_by_id(ident=caseId, session=session)                    target_case_steps: Sequence[TestCaseStep] = await TestCaseStepMapper.query_steps_by_case_id(                        case_id=target_case.id,                        session=session)                    new_case = target_case.copy_map                    new_case['case_name'] = new_case['case_name'] + " - 副本"                    new_case['creator'] = user.id                    new_case['creatorName'] = user.username                    new_case_obj = await cls.save_no_session(session=session, **new_case)                    for step in target_case_steps:                        new_step = step.copy_map                        new_step['test_case_id'] = new_case_obj.id                        new_step['creator'] = user.id                        new_step['creatorName'] = user.username                        await TestCaseStepMapper.save_no_session(session=session, **new_step)                    if requirementId:                        req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                        req.case_number += 1                        last_step_index = await get_last_index(session, new_case_obj.id)                        await session.execute((insert(RequirementCaseAssociation).values(                            dict(                                requirement_id=requirementId,                                case_id=new_case_obj.id,                                order=last_step_index + 1                            )                        )))                    await CaseDynamicMapper.new_dynamic(                        cr=user,                        case=new_case_obj,                        session=session                    )        except Exception as e:            raise e    @classmethod    async def add_default_case(cls, requirementId: int, user: User):        try:            async with async_session() as session:                async with session.begin():                    tc = TestCase()                    await tc.set_default(user)                    await cls.add_flush_expunge(session=session, model=tc)                    req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                    req.case_number += 1                    last_step_index = await get_last_index(session, requirementId)                    await session.execute((insert(RequirementCaseAssociation).values(                        dict(                            requirement_id=requirementId,                            case_id=tc.id,                            order=last_step_index + 1                        )                    )))        except Exception as e:            raise eclass TestCaseStepMapper(Mapper):    __model__ = TestCaseStep    @classmethod    async def reorder_steps(cls, stepIds: List[int]):        """        用例下步骤重新排序        """        try:            async with async_session() as session:                for index, stepId in enumerate(stepIds, start=1):                    await session.execute(update(TestCaseStep).where(                        TestCaseStep.id == stepId                    ).values(                        order=index                    ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def copy_step(cls, stepId: int, user: User):        try:            async with async_session() as session:                step: TestCaseStep = await cls.get_by_id(ident=stepId, session=session)                new_step = step.copy_map                new_step['creator'] = user.id                new_step['creatorName'] = user.username                last_order = await cls.get_last_order(caseId=step.test_case_id, session=session)                new_step["order"] = last_order + 1                await cls.save_no_session(session=session, **new_step)        except Exception as e:            raise e    @classmethod    async def add_default_step(cls, caseId: int, user: User):        try:            async with async_session() as session:                last_order = await cls.get_last_order(caseId=caseId, session=session)                session.add(cls.__model__(                    test_case_id=caseId,                    # expected_result="请输入预期结果",                    # action="请输入操作步骤",                    order=last_order + 1,                    creator=user.id,                    creatorName=user.username                ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def save_steps(cls, caseId: int, steps: List[Dict[str, Any]], session: AsyncSession):        try:            for index, step in enumerate(steps):                step["test_case_id"] = caseId                step["order"] = index                await cls.save_no_session(session=session, **step)        except Exception as e:            raise e    @classmethod    async def query_steps_by_case_id(cls, case_id: int, session: AsyncSession) -> Sequence[TestCaseStep]:        try:            steps = await session.scalars(select(TestCaseStep).where(                TestCaseStep.test_case_id == case_id            ).order_by(TestCaseStep.order))            return steps.all()        except Exception as e:            raise e    @staticmethod    async def get_last_order(caseId: int, session: AsyncSession):        try:            stmt = await session.execute(select(TestCaseStep.order).where(                TestCaseStep.test_case_id == caseId            ).order_by(TestCaseStep.order.desc()).limit(1))            last_step_order = stmt.scalar()            return last_step_order or 0        except Exception as e:            raise eclass CaseDynamicMapper(Mapper):    __model__ = CaseStepDynamic    @classmethod    async def query_dynamic(cls, caseId: int):        """        获取用例动态        """        try:            async with async_session() as session:                dynamic = await session.scalars(select(CaseStepDynamic).where(                    CaseStepDynamic.test_case_id == caseId                ).order_by(CaseStepDynamic.create_time.asc()))                return dynamic.all()        except Exception as e:            raise e    @classmethod    async def new_dynamic(cls, cr: User, case: TestCase, session: AsyncSession):        """        首次创建动态写入        """        dynamicInfo = dict(            description=f"{cr.username} 创建了测试用例。 {case.case_name}",            test_case_id=case.id,            creator=cr.id,            creatorName=cr.username        )        await cls.save_no_session(session=session, **dynamicInfo)    @classmethod    async def update_dynamic(cls, cr: User, case_id: int, old_case: Dict[str, Any], new_case: Dict[str, Any],                             session: AsyncSession):        """        更新用例        """        diff_info = diff_dict(old_case, new_case)        if not diff_info:            return        updateInfo = f"{cr.username} 更新了测试用例 :{diff_info} "        dynamic_obj = CaseStepDynamic(            description=updateInfo,            test_case_id=case_id,            creator=cr.id,            creatorName=cr.username        )        session.add(dynamic_obj)        await session.flush()def diff_dict(old_case: Dict[str, Any], new_case: Dict[str, Any]) -> str:    """比较两个字典的差异，生成变更描述列表"""    # 配置常量    IGNORE_KEYS = {"id", "uid", "create_time", "update_time", "creator", "creatorName", "updater", "updaterName"}    KEY_MAP = {        "case_name": "用例名称",        "case_level": "用例等级",        "case_type": "用例类型",        "case_tag": "用例标签",        "case_setup": "前置条件",        "case_status": "用例状态",        "case_mark": "用例描述",        "is_review": "是否审核",    }    diff_args = []    # 检查所有可能变更的键    all_keys = set(old_case.keys()) | set(new_case.keys())    relevant_keys = all_keys - IGNORE_KEYS    for key in relevant_keys:        old_value = old_case.get(key)        new_value = new_case.get(key)        # 跳过未变化的字段        if old_value == new_value:            continue        # 获取字段显示名称        field_name = KEY_MAP.get(key, key)        # 转换值显示        old_display = _transform_value(key, old_value)        new_display = _transform_value(key, new_value)        # 生成变更描述        if old_value is None:            diff_args.append(f"{field_name} 新增 {new_display}")        elif new_value is None:            diff_args.append(f"{field_name} 从 {old_display} 变更为 空")        else:            diff_args.append(f"{field_name} 从 {old_display} 变更为 {new_display}")    return "\n".join(diff_args)def _transform_value(field_key: str, value: Any) -> str:    """根据字段类型转换值的显示格式"""    if value is None:        return "空"    # 特定字段的值映射    VALUE_MAPPINGS = {        "case_type": {            1: "冒烟",            2: "普通"        },        "is_review": {            True: "已评审",            False: "未评审"        }    }    # 应用值映射    if field_key in VALUE_MAPPINGS and value in VALUE_MAPPINGS[field_key]:        return VALUE_MAPPINGS[field_key][value]    # 处理列表类型（如标签）    if isinstance(value, list):        return "、".join(str(v) for v in value) if value else "空"    # 处理布尔值    if isinstance(value, bool):        return "是" if value else "否"    return str(value)