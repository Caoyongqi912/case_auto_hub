#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : _response# @Software: PyCharm# @Desc:import jsonfrom datetime import datetimefrom decimal import Decimalfrom typing import Any, Optional, Union, Set, Dict, Tuple, Callable, Listfrom pydantic import BaseModelimport dataclassesfrom types import GeneratorTypefrom enum import Enumfrom pathlib import PurePathfrom collections import defaultdictfrom pydantic.json import ENCODERS_BY_TYPESetIntStr = Set[Union[int, str]]DictIntStrAny = Dict[Union[int, str], Any]TupleIntStr = Tuple[str]class Response:    @staticmethod    def encode_json(data: Any, *exclude: str):        return jsonable_encoder(data, exclude=exclude, custom_encoder={            datetime: lambda x: x.strftime("%Y-%m-%d %H:%M:%S")        })    @staticmethod    def success(data=None, code: int = 0, msg: str = "ok", exclude=()):        return Response.encode_json(dict(code=code, data=data, msg=msg), *exclude)def generate_encoders_by_class_tuples(type_encoder_map: Dict) -> Dict:    encoders_by_class_tuples: Dict = defaultdict(tuple)    for type_, encoder in type_encoder_map.items():        encoders_by_class_tuples[encoder] += (type_,)    return encoders_by_class_tuples# ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {#     bytes: lambda o: o.decode(),#     Color: str,#     datetime.date: isoformat,#     datetime.datetime: isoformat,#     datetime.time: isoformat,#     datetime.timedelta: lambda td: td.total_seconds(),#     Decimal: decimal_encoder,#     Enum: lambda o: o.value,#     frozenset: list,#     deque: list,#     GeneratorType: list,#     IPv4Address: str,#     IPv4Interface: str,#     IPv4Network: str,#     IPv6Address: str,#     IPv6Interface: str,#     IPv6Network: str,#     NameEmail: str,#     Path: str,#     Pattern: lambda o: o.pattern,#     SecretBytes: str,#     SecretStr: str,#     set: list,#     UUID: str,# }encoders_by_class_tuples = generate_encoders_by_class_tuples(ENCODERS_BY_TYPE)def jsonable_encoder(        obj: Any,        include: Optional[Union[SetIntStr, DictIntStrAny, TupleIntStr]] = None,        exclude: Optional[Union[SetIntStr, DictIntStrAny, TupleIntStr]] = None,        by_alias: bool = True,        exclude_unset: bool = False,        exclude_defaults: bool = False,        exclude_none: bool = False,        custom_encoder: Optional[Dict[Any, Callable[[Any], Any]]] = None,        sqlalchemy_safe: bool = True) -> Any:    """       将任意对象编码为可JSON序列化的格式。       这个函数设计用于处理复杂的数据结构，包括自定义类实例、Pydantic模型、数据类等。       它支持包括和排除特定字段、处理枚举、路径对象，并可以安全地处理SQLAlchemy相关对象。       参数:       - obj: 需要被编码的对象。       - include: 明确指定需要包含的属性或字段。       - exclude: 明确指定需要排除的属性或字段。       - by_alias: 是否按照别名进行编码。       - exclude_unset: 是否排除未设置的字段。       - exclude_defaults: 是否排除默认值的字段。       - exclude_none: 是否排除值为None的字段。       - custom_encoder: 自定义的编码器字典，用于特定类型的对象编码。       - sqlalchemy_safe: 是否对SQLAlchemy相关对象进行安全编码。       返回:       - 可JSON序列化的对象，通常是字典、列表或其他基本类型。       """    # 使用自定义编码器进行优先处理    custom_encoder = custom_encoder or {}    if custom_encoder:        if type(obj) in custom_encoder:            return custom_encoder[type(obj)](obj)        else:            for encoder_type, encoder_instance in custom_encoder.items():                if isinstance(obj, encoder_type):                    return encoder_instance(obj)    # 处理include和exclude参数，确保它们是集合类型    if include is not None and not isinstance(include, (set, dict)):        include = set(include)    if exclude is not None and not isinstance(exclude, (set, dict)):        exclude = set(exclude)    # 编码Pydantic模型实例    if isinstance(obj, BaseModel):        encoder = getattr(obj.__config__, "json_encoders", {})        if custom_encoder:            encoder.update(custom_encoder)        obj_dict = obj.dict(            include=include,  # type: ignore # in Pydantic            exclude=exclude,  # type: ignore # in Pydantic            by_alias=by_alias,            exclude_unset=exclude_unset,            exclude_none=exclude_none,            exclude_defaults=exclude_defaults,        )        if "__root__" in obj_dict:            obj_dict = obj_dict["__root__"]        return jsonable_encoder(            obj_dict,            exclude_none=exclude_none,            exclude_defaults=exclude_defaults,            custom_encoder=encoder,            sqlalchemy_safe=sqlalchemy_safe,        )    # 处理数据类实例    if dataclasses.is_dataclass(obj):        return dataclasses.asdict(obj)    #  处理枚举    if isinstance(obj, Enum):        return obj.value    # 处理编码路径对象    if isinstance(obj, PurePath):        return str(obj)    # 基本类型    if isinstance(obj, (str, int, float, type(None))):        return obj    # 编码字典类型    if isinstance(obj, dict):        encoded_dict = {}        for key, value in obj.items():            if (                    (                            not sqlalchemy_safe                            or (not isinstance(key, str))                            or (not key.startswith("_sa"))                    )                    and (value is not None or not exclude_none)                    and ((include and key in include) or not exclude or key not in exclude)            ):                encoded_key = jsonable_encoder(                    key,                    exclude=exclude,                    by_alias=by_alias,                    exclude_unset=exclude_unset,                    exclude_none=exclude_none,                    custom_encoder=custom_encoder,                    sqlalchemy_safe=sqlalchemy_safe,                )                encoded_value = jsonable_encoder(                    value,                    by_alias=by_alias,                    exclude=exclude,                    exclude_unset=exclude_unset,                    exclude_none=exclude_none,                    custom_encoder=custom_encoder,                    sqlalchemy_safe=sqlalchemy_safe,                )                encoded_dict[encoded_key] = encoded_value        return encoded_dict    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple)):        encoded_list = []        for item in obj:            encoded_list.append(                jsonable_encoder(                    item,                    include=include,                    exclude=exclude,                    by_alias=by_alias,                    exclude_unset=exclude_unset,                    exclude_defaults=exclude_defaults,                    exclude_none=exclude_none,                    custom_encoder=custom_encoder,                    sqlalchemy_safe=sqlalchemy_safe,                )            )        return encoded_list    if type(obj) in ENCODERS_BY_TYPE:        return ENCODERS_BY_TYPE[type(obj)](obj)    for encoder, classes_tuple in encoders_by_class_tuples.items():        if isinstance(obj, classes_tuple):            return encoder(obj)    errors: List[Exception] = []    try:        data = dict(obj)    except Exception as e:        errors.append(e)        try:            data = vars(obj)        except Exception as e:            errors.append(e)            raise ValueError(errors)    return jsonable_encoder(        data,        by_alias=by_alias,        exclude=exclude,        exclude_unset=exclude_unset,        exclude_defaults=exclude_defaults,        exclude_none=exclude_none,        custom_encoder=custom_encoder,        sqlalchemy_safe=sqlalchemy_safe,    )class JsonEncoder(json.JSONEncoder):    def default(self, o: Any) -> Any:        if isinstance(o, set):            return list(o)        if isinstance(o, datetime):            return o.strftime("%Y-%m-%d %H:%M:%S")        if isinstance(o, Decimal):            return str(o)        if isinstance(o, bytes):            return o.decode(encoding='utf-8')        return self.default(o)