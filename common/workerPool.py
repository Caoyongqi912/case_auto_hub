#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/12/2# @Author : cyq# @File : workerPool# @Software: PyCharm# @Desc:import asynciofrom config import Configimport timeimport uuidfrom dataclasses import dataclass, fieldfrom asyncio import Queue, Lockfrom datetime import datetimefrom enum import Enumfrom typing import Optional, Dict, List, Callable, Any, Unionfrom utils import logfrom fastapi import Request, HTTPExceptionclass JobStatus(Enum):    """任务状态"""    PENDING = "pending"  # 等待中    RUNNING = "running"  # 执行中    COMPLETED = "completed"  # 已完成    FAILED = "failed"  # 失败    CANCELLED = "cancelled"  # 已取消@dataclassclass JOB:    """    任务对象    """    id: int | str    name: str    func: Callable    args: tuple = field(default_factory=tuple)    kwargs: dict = field(default_factory=dict)    status: JobStatus = JobStatus.PENDING    result: Optional[Any] = None    error: Optional[str] = None    start_time: Optional[float] = None    end_time: Optional[float] = None    created_at: float = field(default_factory=time.time)    def __post_init__(self):        if not self.id:            self.id = str(uuid.uuid4())[:8]    @property    def duration(self) -> Optional[float]:        """执行时长"""        if self.start_time and self.end_time:            return self.end_time - self.start_time        return Noneclass WorkerPool:    _instance: Optional['WorkerPool'] = None    @classmethod    def get_instance(cls, worker_count: int = 5):        """获取单例实例"""        if cls._instance is None:            cls._instance = cls(worker_count)        return cls._instance    def __init__(self, worker_count: int = 5):        self.worker_count = worker_count        self.job_queue = Queue(maxsize=20)        self.workers: List[asyncio.Task] = []        self.jobs: Dict[str, JOB] = {}  # 所有任务        self.running_jobs: Dict[str, JOB] = {}  # 运行中的任务        self.completed_jobs: List[JOB] = []  # 已完成的任务        self.job_lock = Lock()  # 保护jobs字典        self.is_running = False        self.monitor_task: Optional[asyncio.Task] = None        log.info(f"初始化任务池,  {worker_count} 个 worker")    async def submit(self, func: Callable, name: str, args: tuple = (), kwargs: dict = None) -> str:        """        提交任务        return job id        """        if not kwargs:            kwargs = {}        job = JOB(id=str(uuid.uuid4()), name=name, func=func, args=args, kwargs=kwargs)        # 保存任务        async with self.job_lock:            self.jobs[job.id] = job        # 提交到队列        await self.job_queue.put(job)        queue_size = self.job_queue.qsize()        log.info(f"Submitted job {job.id}: {name} , queue: {queue_size})")        return job.id    async def submit_batch(self, jobs: List[dict]):        """批量提交"""        job_ids = []        for job_spec in jobs:            job_id = await self.submit(                func=job_spec['func'],                name=job_spec.get('name', 'Unnamed Job'),                args=job_spec.get('args', ()),                kwargs=job_spec.get('kwargs', {}),            )            job_ids.append(job_id)        log.info(f"Submitted {len(job_ids)} jobs in batch")        return job_ids    async def cancel_job(self, job_id: str):        """取消队列中的任务"""        async with self.job_lock:            _job = self.jobs.get(job_id)            if not _job:                log.warning(f"Cannot cancel job {job_id}: not found")                return False            if _job.status == JobStatus.PENDING:                log.warning(f"Cannot cancel job {job_id}: already {_job.status.value}")                return False            # 标记为取消            _job.status = JobStatus.CANCELLED            _job.end_time = time.time()            log.info(f"Cancelled job {job_id}")            return True    async def get_job_status(self, job_id: str):        """获取任务状态"""        async with self.job_lock:            job = self.jobs.get(job_id)        if not job:            return None        return {            'id': job.id,            'name': job.name,            'status': job.status.value,            'created_at': datetime.fromtimestamp(job.created_at).isoformat(),            'start_time': datetime.fromtimestamp(job.start_time).isoformat() if job.start_time else None,            'end_time': datetime.fromtimestamp(job.end_time).isoformat() if job.end_time else None,            'duration': job.duration,            'result': job.result,            'error': job.error,        }    async def get_stats(self) -> dict:        """统计信息"""        async with self.job_lock:            completed = len([j for j in self.completed_jobs if j.status == JobStatus.COMPLETED])            failed = len([j for j in self.completed_jobs if j.status == JobStatus.FAILED])            return {                'total': len(self.jobs),                'active': len(self.running_jobs),                'queue': self.job_queue.qsize(),                'completed': completed,                'failed': failed,                'pending': len([j for j in self.jobs.values() if j.status == JobStatus.PENDING])            }    @property    def queue_info(self) -> Dict[str, Any]:        """获取队列信息"""        return {            'max_workers': self.worker_count,            'queue_size': self.job_queue.qsize(),            'is_running': self.is_running        }    async def start(self):        """工作池启动"""        if self.is_running:            log.warning("工作池已启动")            return        self.is_running = True        # 启动工作进程        self.workers = [            asyncio.create_task(self._worker(i), name=f"Worker-{i}") for i in range(self.worker_count)        ]        # 监控        self.monitor_task = asyncio.create_task(self._monitor(), name="worker-monitor")        log.info(f"WorkerPool started with {self.worker_count} workers")    async def stop(self):        """停止工作池"""        if not self.is_running:            return        log.info("STEP WorkerPool")        self.is_running = False        # 发送停止信号给所有worker        for _ in range(self.worker_count):            await self.job_queue.put(None)        # 等待所有worker完成        if self.workers:            await asyncio.gather(*self.workers, return_exceptions=True)        # 停止监控任务        if self.monitor_task:            self.monitor_task.cancel()            try:                await self.monitor_task            except asyncio.CancelledError:                pass        log.info("WorkerPool stopped")    async def _worker(self, worker_id: int):        """工作携程"""        worker_name = f"Worker - {worker_id}"        log.info(f"{worker_name} started")        while self.is_running:            try:                job = await  self.job_queue.get()                if job is None:                    log.info(f"{worker_name}  received stop signal ")                    self.job_queue.task_done()                    break                # 任务更新状态                async with self.job_lock:                    job.status = JobStatus.RUNNING                    job.start_time = time.time()                    self.running_jobs[job.id] = job                queue_size = self.job_queue.qsize()                log.info(f"{worker_name} processing job {job.id}: {job.name} "                         f"(queue: {queue_size}, running: {len(self.running_jobs)})")                try:                    # 执行任务                    result = await job.func(*job.args, **job.kwargs)                    async with self.job_lock:                        job.status = JobStatus.COMPLETED                        job.result = result                        job.end_time = time.time()                        self.completed_jobs.append(job)                        del self.running_jobs[job.id]                    duration = job.duration or 0                    log.info(f"{worker_name} completed job {job.id} in {duration:.2f}s")                except asyncio.CancelledError:                    # 任务被取消                    async with self.job_lock:                        job.status = JobStatus.CANCELLED                        job.end_time = time.time()                        self.running_jobs.pop(job.id, None)                    log.warning(f"{worker_name} job {job.id} was cancelled")                    raise                except Exception as e:                    # 任务执行失败                    async with self.job_lock:                        job.status = JobStatus.FAILED                        job.error = str(e)                        job.end_time = time.time()                        self.running_jobs.pop(job.id, None)                        self.completed_jobs.append(job)                    log.error(f"{worker_name} job {job.id} failed: {e}")                self.job_queue.task_done()            except Exception as e:                log.error(f"{worker_name} unexpected error: {e}")            log.info(f"{worker_name} stopped")    async def _monitor(self):        """队列监控"""        try:            log.info("[Monitor] Start")            while self.is_running:                await asyncio.sleep(5)                stats = await self.get_stats()                log.info(                    f"[Monitor] Active: {stats['active']}, "                    f"Queue: {stats['queue']}, "                    f"Completed: {stats['completed']}, "                    f"Failed: {stats['failed']}"                )        except asyncio.CancelledError:            log.info("[Monitor] Stopped")pool = WorkerPool.get_instance(Config.TASK_WORKER_POOL_SIZE)async def get_worker_pool(request: Request) -> Union[WorkerPool, None]:    """"""    worker_pool = request.app.worker_pool    return worker_pool__all__ = (    "pool",    "get_worker_pool")