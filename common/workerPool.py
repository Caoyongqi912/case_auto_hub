#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/12/2# @Author : cyq# @File : workerPool# @Software: PyCharm# @Desc:import asynciofrom dataclasses import dataclassfrom asyncio import Queuefrom typing import Optional, Dict, Listfrom utils import log@dataclassclass ExecuteTaskRequest:    """执行任务请求"""    task_id: int    env_id: Optional[int] = None    options: Optional[List[str]] = None    user_context: Optional[Dict] = None  # 用户上下文信息class OptimizedTaskWorkerPool:    def __init__(self, max_workers: int = 5):        self.max_workers = max_workers        self.task_queue = Queue(maxsize=20)        self.workers = []        self.running_tasks = {}        self.completed_tasks = []    async def execute_task(self, task_id: int, env_id: int):        """执行任务"""        log.info(f"execute_task {task_id}")        await asyncio.sleep(10)        return {"status": "success", "task_id": task_id}    async def worker(self, worker_id: int):        log.info(f"工作进程 {worker_id} 开始")        while True:            try:                task: ExecuteTaskRequest = await self.task_queue.get()                if task is None:                    log.info(f"工作进程 {worker_id} 停止")                    break                self.running_tasks[task.task_id] = {                    "worker_id": worker_id,                    "start_time": asyncio.get_event_loop().time()                }                log.info(f"[Worker-{worker_id}] Processing task {task.task_id} "                         f"(Queue: {self.task_queue.qsize()})")                result = await self.execute_task(task.task_id, task.env_id)                # 记录完成                self.running_tasks.pop(task.task_id, None)                self.completed_tasks.append({                    'task_id': task.task_id,                    'result': result,                    'worker_id': worker_id                })                log.info(f"[Worker-{worker_id}] Completed task {task.task_id}")            except asyncio.CancelledError:                log.error(f"[Worker-{worker_id}] Cancelled")                break            except Exception as e:                log.error(f"[Worker-{worker_id}] Error processing task: {e}")                # 记录失败任务                self.completed_tasks.append({                    'task_id': task.task_id if 'request' in locals() else 'unknown',                    'error': str(e),                    'worker_id': worker_id                })            finally:                self.task_queue.task_done()    async def submit_task(self, task_id: int, env_id: int):        """添加任务到队列"""        task = ExecuteTaskRequest(task_id=task_id, env_id=env_id, options=["API", "CASE"])        current_queue = self.task_queue.qsize()        current_running = len(self.running_tasks)        log.info(f"[System] Submitting task {task_id}")        log.info(f"Queue: {current_queue} waiting, Running: {current_running}/{self.max_workers}")        if self.task_queue.full():            log.warning(f"[System] Queue is full, waiting for available space...")            return False        await self.task_queue.put(task)        return True    async def monitor(self, interval: int = 5):        """队列监控"""        try:            while True:                await asyncio.sleep(interval)                log.info(f"\n[Monitor] Workers: {self.max_workers} | "                         f"Running: {len(self.running_tasks)} | "                         f"Queue: {self.task_queue.qsize()} | "                         f"Completed: {len(self.completed_tasks)}")                if self.running_tasks:                    current_time = asyncio.get_event_loop().time()                    log.info("Currently running tasks:")                    for task_id, info in self.running_tasks.items():                        elapsed = current_time - info['start_time']                        log.info(f"  Task {task_id}: worker-{info['worker_id']}, "                                 f"running for {elapsed:.1f}s")        except asyncio.CancelledError:            log.error("[Monitor] Stopped")    async def start(self):        """启动工作池"""        log.info(f"[TaskWorkerPool] Starting {self.max_workers} workers...")        self.workers = [            asyncio.create_task(self.worker(i))            for i in range(self.max_workers)        ]    async def stop(self):        """停止工作池"""        log.info("[TaskWorkerPool] Stopping workers...")        # 发送停止信号        for _ in range(self.max_workers):            await self.task_queue.put(None)        # 等待所有worker完成        await asyncio.gather(*self.workers, return_exceptions=True)        log.info("[TaskWorkerPool] All workers stopped")async def performance_test():    """性能测试"""    print("=" * 60)    print("任务工作池性能测试")    print("=" * 60)    # 创建工作池    worker_pool = OptimizedTaskWorkerPool(        max_workers=5,  # 5个工作协程    )    # 启动worker    await worker_pool.start()    # 启动监控    monitor_task = asyncio.create_task(worker_pool.monitor())    # 提交一批任务进行测试    tasks_to_submit = 20    print(f"\n[Test] Submitting {tasks_to_submit} tasks...")    submit_tasks = []    for i in range(1, tasks_to_submit + 1):        # 模拟不同参数的任务        options = ['API'] if i % 2 == 0 else ['API', 'CASE']        env_id = i % 3 if i % 3 != 0 else None        task = asyncio.create_task(            worker_pool.submit_task(                task_id=i,                env_id=env_id,            )        )        submit_tasks.append(task)        await asyncio.sleep(0.2)  # 模拟任务提交间隔    # 等待所有任务提交完成    await asyncio.gather(*submit_tasks)    # 等待队列清空    print("\n[Test] Waiting for all tasks to complete...")    await worker_pool.task_queue.join()    # 停止监控    monitor_task.cancel()    # 停止worker池    await worker_pool.stop()    # 性能统计    print("\n" + "=" * 60)    print("性能统计:")    print(f"总提交任务数: {tasks_to_submit}")    print(        f"成功完成数: {len([t for t in worker_pool.completed_tasks if t.get('result', {}).get('status') == 'success'])}")    if worker_pool.completed_tasks:        # 计算平均执行时间（如果有时间信息）        print("=" * 60)if __name__ == '__main__':    asyncio.run(performance_test())