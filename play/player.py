#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/8# @Author : cyq# @File : player# @Software: PyCharm# @Desc:import asynciofrom typing import List, Dict, NoReturnfrom playwright.async_api import async_playwright, Page, Playwright, BrowserContext, Browser, LocatorAssertionsfrom playwright._impl._errors import TimeoutError, TargetClosedErrorfrom app.exception.err_handle_func import UIRuntimeErrorfrom app.mapper.ui.uiCaseMapper import UICaseStepApiMapper, UICaseStepSQLMapperfrom app.mapper.ui.uiCaseStepGroupMapper import UICaseStepGroupMapperfrom app.mapper.ui.uiCaseVariableMapper import UICaseVariableMapperfrom app.mapper.ui.uiEnvMapper import UIEnvMapperfrom model.ui import UICaseModel, UICaseStepsModel, UICaseTaskResultBaseModel, UIResultModel, \    UIStepAPIModel, UIEnvModel, UIStepSQLModel, UITaskModelfrom enums.CaseEnum import Statusfrom app.mapper.ui.uiCaseMapper import UICaseMapperfrom app.mapper.ui.uiTaskMapper import UITaskMapperfrom play.exception import PlayAssertException, APIAssertException, CBSLoginFailfrom play.apiSender import APISenderfrom play.sqlSender import SqlSenderfrom utils import logfrom utils.wrapper_ import lockfrom utils.report import Reportfrom play.play import Play, CustomizeMethod, PlayKeyboardfrom play.writer import Writerfrom play.logWriter import LogWriterfrom play.extract import ExtractManagerfrom config import Configimport jenkinsdef getAssertErrorMsg(e) -> str:    if isinstance(e, (AssertionError, LocatorAssertions)):        return ",".join(str(e).split("Call log:")[:1])async def format_error_info(step_index: int, step: UICaseStepsModel,                            e: Exception) -> Dict[str, str]:    """    格式化错误执行信息    :param step_index: 步骤索引    :param step: UICaseStepsModel    :param e:Exception    :return:    """    error_info = {        "ui_case_err_step": step_index,        "ui_case_err_step_title": step.name,        "ui_case_err_step_msg": str(e)    }    if isinstance(e, LocatorAssertions):        msg = getAssertErrorMsg(e)        error_info[            "ui_case_err_step_msg"] = f"{e.__class__.__name__}❌: {msg} << "    elif isinstance(e, TimeoutError):        error_info[            "ui_case_err_step_msg"] = (f"{e.__class__.__name__}❌: Timeout waiting for locator \n"                                       f">> '{step.locator}' << ")    elif isinstance(e, PlayAssertException):        msg = getAssertErrorMsg(e)        error_info["ui_case_err_step_msg"] = (f"{e.__class__.__name__}❌: method >> '{step.method}' << \n"                                              f"{msg}")    elif isinstance(e, APIAssertException):        error_info["ui_case_err_step_msg"] = f"🚀 {e.__class__.__name__}❌: {str(e)}"    elif isinstance(e, TargetClosedError):        error_info["ui_case_err_step_msg"] = f"🚀 {e.__class__.__name__}❌: {str(e)}"    return error_infoasync def run_Tasks(taskIds: List[int], userId: int, jobName: str = None):    """    run for jenkins    :param taskIds:    :param userId:    :param jobName:    :return:    """    try:        tasks = [Player().run_task(task, userId) for task in taskIds]        await asyncio.gather(*tasks)    except Exception as e:        log.error(e)    finally:        if jobName:            log.info(f'=========={jobName}')            server = jenkins.Jenkins(url=Config.JENKINS_URL,                                     username=Config.JENKINS_USERNAME,                                     password=Config.JENKINS_PASSWORD)            log.info(f'build=========={jobName}')            server.build_job(jobName)class AsyncPlay:    @classmethod    async def play(cls) -> Playwright:        return await async_playwright().start()class TaskChecker:    @staticmethod    async def check_cases(task: UITaskModel) -> List[UICaseModel]:        """        检查用例        :param task:        :return:        """        task_cases: List[UICaseModel] = await UITaskMapper.query_cases_by_task_id(task.id)        # 无待执行用例，结束        number_of_pending_use_cases = len(task_cases)        if number_of_pending_use_cases == 0:            log.error(f'无待执行用例，结束。')            raise UIRuntimeError("无待执行用例，结束。")        return task_casesclass Player:    """    UI自动化 处理与执行    """    play: Playwright    page: Page    browser: Browser    context: BrowserContext    logger: LogWriter    em: ExtractManager    api: APISender    sql: SqlSender    env: UIEnvModel    def __init__(self):        self.logger = LogWriter()    @lock("UI_TASK")    async def run_task(self, taskId: int, userId: int = None):        """        执行ui TASK        :param taskId 待运行TASK ID        :param userId 执行人 ID        """        # 查询任务        task = await UITaskMapper.get_by_id(taskId)        self.logger.taskId = task.uid        await self.logger.write_log(f'执行ui TASK:{task}')        # 探活        await TaskChecker.check_beat(task)        # 查询任务用例        task_cases: List[UICaseModel] = await TaskChecker.check_cases(task)        # 更新任务状态        await Writer.write_task_status(task, Status.RUNNING)        task_result = await Writer.init_task_base_result(            totalNumber=len(task_cases),            task=task,            userId=userId        )        # 执行用例        await self.retry_case(task.retry, task_cases, userId, task_result)        await self.logger.write_log(f'ui TASK:{task} 执行完成')        # 写入结果        try:            await Writer.write_base_result(task_result)        except Exception as e:            log.exception(e)            raise e        finally:            await Writer.write_task_status(task, Status.WAIT)            if task.isSend:                await Report().ui2weChat(task, task_result)    async def retry_case(self, retryNum: int, task_cases: List[UICaseModel], userId, task_result):        """        任务 用例重试执行机制执行        :param retryNum: 重试次数        :param task_cases: 任务用例        :param userId: 执行人        :param task_result: 初始化的任务结果模型        :return:        """        for case in task_cases:            init_case_result = await Writer.init_case_result(case, userId, task_result.id)            self.logger.caseId = case.uid            for i in range(retryNum + 1):                await self.logger.write_log(f'执行ui case :{case} 次数:{i}')                # 如果重试次数为0 或者是最终执行 失败才进行截图处理                retry = retryNum == 0 or i == retryNum                flag = await self.__execute_case(case, init_case_result, task_result, retry)                # 每次执行完关闭 playwright                await self.play.stop()                if not flag:                    if i == retryNum:                        await self.logger.write_log(f'用例:{case} 执行失败  重试次数已用完')                        task_result.failNumber += 1                        await self.logger.clear()                        break                    await self.logger.write_log(f'用例:{case} 执行失败  进行{i + 1}重试')                    continue                else:                    task_result.successNumber += 1                    await self.em.clear()                    await self.logger.clear()                    break    async def run_case(self, caseId: int, userId: int):        """        查询用例 准备执行        :param caseId: 代执行用例        :param userId: 执行人        :return:        """        case = await UICaseMapper.get_by_id(caseId)        self.logger.caseId = case.uid        await self.logger.write_log(f"准备执行用例 :{case}")        init_case_result = await Writer.init_case_result(case, userId)        await self.__execute_case(case, init_case_result)    async def __init_extracts(self, case: UICaseModel):        """        初始化变量        :param case: UICaseModel        :return:        """        # 初始化变量        self.em = ExtractManager(case.id)        variables = await UICaseVariableMapper.query_by(caseId=case.id)        await self.em.initBeforeVars(variables)        await self.logger.write_log(f"初始化变量 :{self.em.variables}")    async def __execute_case(self,                             case: UICaseModel,                             case_result: UIResultModel,                             task_result: UICaseTaskResultBaseModel = None,                             retry: bool = True):        """        case 执行        :param case: 待执行用例        :param case_result: 初始化的用例结果模型        :param task_result: 初始化的批量执行结果模型        :param retry: 重试逻辑        :return:        """        errorInfo = {}        _flag = True        # 执行准备        case_steps: List[UICaseStepsModel] = await UICaseMapper.query_steps_by_caseId(case.id)        await self.logger.write_log(f"获取用例步骤 :{len(case_steps)}")        if len(case_steps) == 0:            await self.logger.write_log(f"无用例步骤⚠️ 运行结束")            await Writer.write_case_result(case_result, self.logger)            return _flag        # 初始化play        await self.__init_play()        # 初始化变量        await self.__init_extracts(case)        try:            # 初始化浏览器 进行登陆            await self.__cbs_login(case, case_result, retry)        except Exception as e:            # 登录失败            log.error(e)            if task_result:                return False        try:            # 步骤执行            for i, step in enumerate(case_steps, start=1):                try:                    await self.__condition_execute(i, step, case_result)                except Exception as e:                    log.exception(e)                    await self.logger.write_log(f'some error : {str(e)}')                    await self.logger.write_log(f"步骤执行失败 >> {step}")                    # is_ignore true 忽略本次失败 、继续                    if step.is_ignore:                        await self.logger.write_log('step is ignore, continue...')                        continue                    _flag = False                    # 是否重试 、重试次数用完                    if retry:                        errorInfo = await format_error_info(i, step, e)                        # 页面关闭、 接口请求失败 、不截图                        if not isinstance(e, (TargetClosedError, APIAssertException)):                            errorPath = await CustomizeMethod.to_screenshot(self.page, self.logger)                            errorInfo['ui_case_err_step_pic_path'] = errorPath                    break        finally:            await self.logger.write_log(f'执行完成 >> {case},结果:{_flag}')            return await self.run_finally(                _flag,                task_result,                case_result,                errorInfo            )    async def run_finally(self, flag: bool,                          task_result: UICaseTaskResultBaseModel,                          case_result: UIResultModel,                          errorInfo):        # 确保最终执行写入操作        try:            await Writer.write_case_result(case_result, self.logger, errorInfo)        except Exception as e:            log.error(e)        finally:            if task_result:                return flag            else:                await self.page.close()                await self.context.close()                await self.play.stop()    async def __condition_execute(self, i: int, step: UICaseStepsModel, case_result: UIResultModel):        """        条件执行        :param i:        :param step:        :param case_result:        :return:        """        stepApi: UIStepAPIModel = await UICaseStepApiMapper.get_by(stepId=step.id)        stepSql: UIStepSQLModel = await UICaseStepSQLMapper.get_by(stepId=step.id)        # 如果都有前置 API 和 SQL        if stepApi and stepSql:            if stepApi.b_or_a and stepSql.b_or_a:  # 前置                await self.__execute_api(stepApi, step, case_result)                await self.__execute_sql(stepSql)                await self.__execute_step(i, step)            elif stepApi.b_or_a or stepSql.b_or_a:  # 其中一个前置                if stepApi.b_or_a:  # API 前置                    await self.__execute_api(stepApi, step, case_result)                else:  # SQL 前置                    await self.__execute_sql(stepSql)                await self.__execute_step(i, step)                if not stepApi.b_or_a:  # API 后置                    await self.__execute_api(stepApi, step, case_result)                if not stepSql.b_or_a:  # SQL 后置                    await self.__execute_sql(stepSql)            else:  # 都为后置                await self.__execute_step(i, step)                if stepApi:  # 执行 API                    await self.__execute_api(stepApi, step, case_result)                if stepSql:  # 执行 SQL                    await self.__execute_sql(stepSql)        elif stepApi:  # 仅有 API            if stepApi.b_or_a:  # 前置                await self.__execute_api(stepApi, step, case_result)                await self.__execute_step(i, step)            else:  # 后置                await self.__execute_step(i, step)                await self.__execute_api(stepApi, step, case_result)        elif stepSql:  # 仅有 SQL            if stepSql.b_or_a:  # 前置                await self.__execute_sql(stepSql)                await self.__execute_step(i, step)            else:  # 后置                await self.__execute_step(i, step)                await self.__execute_sql(stepSql)        else:  # 都没有            # 判断是否是step group            if step.is_group:                await self.__execute_group_step(i, step)            else:                await self.__execute_step(i, step)    async def __execute_group_step(self, step_index: int, step: UICaseStepsModel):        """        步骤组执行        :param step_index        :param step:        :return:        """        g_steps = await UICaseStepGroupMapper.query_steps_by_groupId(groupId=step.group_Id)        await self.logger.write_log("===== 开始执行步骤组")        for i, step in enumerate(g_steps, start=1):            await self.__execute_step(step_index + i / 10, step)        await self.logger.write_log("===== 执行步骤组结束")    async def __execute_sql(self, stepSQl: UIStepSQLModel):        """        oracle 执行        :param stepSQl:        :return:        """        title = "前置" if stepSQl.b_or_a else "后置"        await self.logger.write_log(f'执行{title}SQL >> {stepSQl.desc}')        newSql = await self.em.transform_target(stepSQl.sql_str)        await self.sql.send_sql(newSql)    async def __execute_api(self, stepApi: UIStepAPIModel,                            step: UICaseStepsModel,                            case_result: UIResultModel):        """        执行前后置API调用        :param stepApi:        :param step:        :param case_result:        :return:        """        title = "前置" if stepApi.b_or_a else "后置"        await self.logger.write_log(f'执行{title}接口 >> {stepApi}')        domain = self.env.domain.split("service=")[-1].split("/base")[0]        # 兼容sit 环境        if not domain.startswith("https"):            domain = domain.replace("http", "https")        # 请求        await self.api(env=domain, stepApi=stepApi)        # 提取变量        if stepApi.extracts:            await self.api.add_extracts(stepApi.extracts)        # 断言        if stepApi.asserts:            await self.api.do_assert(stepApi=stepApi,                                     step=step,                                     case_result=case_result)    async def __execute_step(self, step_index: int,                             step: UICaseStepsModel):        """        执行单步骤        :param step_index:        :param step:        :return:        """        await self.logger.write_log(f'执行步骤 >> {step_index}:{step}')        # 断言        if step.method.startswith("expect"):            return await Play.to_expect(                page=self.page,                step=step,                logger=self.logger,                em=self.em)        # event        if step.method.startswith("on"):            return await Play.api_on(                page=self.page,                step=step,                logger=self.logger,                em=self.em            )        if step.method.startswith("keyboard"):            return await PlayKeyboard.keyboard(page=self.page, step=step, logger=self.logger)        # 打开新页面        if step.new_page:            self.page = await Play.new_page(self.page, step)            return        # 常规        return await Play.play(page=self.page,                               step=step,                               logger=self.logger,                               em=self.em)    async def __get_cookie(self):        """        获取cookie        :return:        """        cookies = await self.context.cookies()        for c in cookies:            if c["name"] == "sid":                await self.logger.write_log(f"获取到Cookie {c}")                await self.api.setCookie(c)    async def __cbs_login(self, case: UICaseModel, case_result, retry=True):        """        cbs 登录        set cookie        :param case: UICaseModel        :param case_result        :param retry        :return:        """        self.env: UIEnvModel = await UIEnvMapper.get_by_uid(case.envId)        try:            # 初始化API            self.api = APISender(logger=self.logger, em=self.em)            # 初始化SQL            self.sql = SqlSender(city=self.env.city,                                 logger=self.logger, em=self.em)            await self.logger.write_log(f"等待登陆 地址:{self.env.domain}")            await self.page.goto(self.env.domain, wait_until="commit")            await self.page.wait_for_load_state()            await self.page.fill("#username", case.username, timeout=1000)            await self.page.fill("#password", case.password, timeout=1000)            await self.page.click("#btn-submit", timeout=5000)            await self.page.wait_for_load_state()            await self.logger.write_log(f"CBS 登录成功 ✅ ")            # setCookie            await self.__get_cookie()        except Exception as e:            log.exception(e)            await self.logger.write_log(f"CBS 登录失败 => {e}")            _flag = False            if retry:                errorInfo = {                    "ui_case_err_step": -1,                    "ui_case_err_step_title": "CBS 登录",                    "ui_case_err_step_msg": str(e)                }                errorPath = await CustomizeMethod.to_screenshot(self.page, self.logger)                errorInfo['ui_case_err_step_pic_path'] = errorPath                await Writer.write_case_result(case_result, self.logger, errorInfo)                await self.page.close()            raise CBSLoginFail(f"CBS 登录失败 => {e}")    async def __init_play(self):        """        初始化playwright        指定            headless True            slow_mo 1s            dev超时5s            pro超时10s        :return:        """        try:            self.play = await AsyncPlay.play()            self.browser = await self.play.chromium.launch(headless=Config.UI_Headless,                                                           timeout=Config.UI_Timeout,                                                           slow_mo=Config.UI_SLOW)            self.context = await self.browser.new_context()            self.context.set_default_timeout(Config.UI_Timeout)            self.page = await self.context.new_page()            await self.logger.write_log(f"初始化浏览器成功 ✅")            await self.logger.write_log(f"Timeout    {Config.UI_Timeout} ✅")            await self.logger.write_log(f"Slow   {Config.UI_SLOW} ✅")        except Exception as e:            log.exception(e)            raise UIRuntimeError("初始化浏览器失败")