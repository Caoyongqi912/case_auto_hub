#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/7/23# @Author : cyq# @File : PlayTaskRunner# @Software: PyCharm# @Desc:import asynciofrom typing import List, Optional, TypeVar, Dict, Anyfrom app.mapper.play import PlayCaseResultMapperfrom app.mapper.play.playTaskMapper import PlayTaskMapper, PlayTaskResultMapperfrom app.model.playUI import PlayTaskResult, PlayCasefrom common.notifyManager import NotifyManagerfrom enums import TaskStatusfrom play.player import Playerfrom play.starter import UIStarterfrom play.writer import Writerfrom utils import logfrom dataclasses import dataclassVARS = TypeVar("VARS", bound=List[Dict[str, Any]] | None)@dataclassclass PlayTaskExecuteParams:    task_id: int | str    retry: int = 0  # 重试次数    retry_interval: int = 0  # 重试间隔    notify_id: Optional[int] = None  # 推送    variables: Optional[VARS] = None  # 变量class PlayTaskRunner:    def __init__(self, starter: UIStarter):        self._runner = starter        self._player = Player(self._runner)    async def execute_task(self, params: PlayTaskExecuteParams):        """        任务执行        """        if isinstance(params.task_id, int):            task = await PlayTaskMapper.get_by_id(ident=params.task_id)        else:            task = await PlayTaskMapper.get_by_uid(uid=params.task_id)        await self._runner.send(f"开始执行任务：{task.title}: {task.desc} BY {self._runner.username}")        # 查询待执行用用例        play_cases = await PlayTaskMapper.query_case(taskId=task.id)        if not play_cases:            log.warning(f"任务：{task.title} 没有可用用例")            return        # 将task 置为 RUNNER        await PlayTaskMapper.set_task_status(taskId=task.id, status=TaskStatus.RUNNING)        # 初始化结果对象        task_result = await PlayTaskResultMapper.init_task_result(            task=task,            case_total_num=len(play_cases),            runner=self._runner        )        try:            await self.__execute_case(retry=params.retry,                                      retry_interval=params.retry_interval,                                      play_cases=play_cases,                                      task_result=task_result)        except Exception as e:            log.exception(e)        finally:            # 写结果            await Writer.write_base_result(base_result=task_result)            if params.notify_id:                await self.nodify_report(params.notify_id, task_result)    async def __execute_case(self,                             retry: int,                             retry_interval: int,                             play_cases: List[PlayCase],                             task_result: PlayTaskResult):        for play_case in play_cases:            await self._runner.send(f"准备执行用例 :{play_case}")            # 初始化case结果对象            play_case_result = await PlayCaseResultMapper.init_case_result(                play_case=play_case,                user=self._runner,                task_result_id=task_result.id,            )            for r in range(retry + 1):                flag = await self._player.execute_case(play_case=play_case,                                                       play_case_result=play_case_result)                if flag:                    task_result.success_number += 1                    break                if r < retry:                    if retry_interval > 0:                        await asyncio.sleep(retry_interval)                    await self._runner.send(f"用例执行失败，开始第 {r + 1} 次重试")                else:                    task_result.fail_number += 1                await self._runner.clear_logs()    @staticmethod    async def nodify_report(notify_id: int, task_result: PlayTaskResult):        """        推送报告        """        n = NotifyManager(notify_id)        await n.push(flag="UI", task_result=task_result)