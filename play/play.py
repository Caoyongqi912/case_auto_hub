#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/9# @Author : cyq# @File : _play# @Software: PyCharm# @Desc:import functoolsfrom typing import Callableimport osfrom config import Configfrom playwright.async_api import Page, expect, PageAssertions, Locator, Playwright, BrowserContextfrom playwright._impl._errors import Errorfrom model.ui import UIEnvModel, UICaseModel, UICaseStepsModel, UIResultModelfrom play.exception import PlayAssertExceptionfrom play.writer import Writerfrom utils import log, GenerateTools, MyJsonPathfrom play.upload_files import path as FilePath, bj_filefrom play.extract import ExtractManagerfrom play.logWriter import LogWriterfrom json import JSONDecodeErrordef get_assert_info(func):    @functools.wraps(func)    async def wrapper(*args, **kwargs):        from utils import GenerateTools        step = kwargs.get("step")        assertInfo = {            "id": GenerateTools.getTime(3),            "type": "UI",            "desc": step.desc,            "actual": "-",            "expect": step.value,            "result": True,            "extraOpt": step.method,            "stepName": step.name,            "assertOpt": "==",            "extraValue": "expect",        }        page = kwargs.get("page")        case_result = kwargs.get("case_result")        method = step.method.split(".")[-1]        if method == "to_have_title":            assertInfo["actual"] = await page.title()        elif method == "to_have_text":            locator = await Play.get_locator(page, step)            try:                actual_value = await locator.text_content(timeout=0)                assertInfo["actual"] = actual_value            except Exception as e:                log.error(e)                assertInfo["actual"] = "未找到元素"        try:            await func(*args, **kwargs)            await Writer.write_assert_info(case_result, [assertInfo])        except Exception as e:            log.error(e)            assertInfo['result'] = False            await Writer.write_assert_info(case_result, [assertInfo])            raise PlayAssertException(e)    return wrapperclass SMethod:    GOTO: str = "goto"    WAIT_FOR_TIMEOUT = "wait_for_timeout"    EVALUATE = "evaluate"    FILL = "fill"    RELOAD = 'reload'    UPLOAD_FILE = "upload_file"    GET_TEXT = 'get_text'    GET_ATTR = "get_attribute"    CHECK_CONTENT = "check_content"    COUNT = "count"    __attr__ = [GOTO,                COUNT,                RELOAD,                FILL,                EVALUATE,                WAIT_FOR_TIMEOUT,                UPLOAD_FILE,                GET_ATTR,                CHECK_CONTENT,                GET_TEXT]class CustomizeMethod:    """    Page Method    """    @staticmethod    async def special_method_processing(page: Page, step: UICaseStepsModel,                                        logger: LogWriter, em: ExtractManager):        """        特殊处理方法        :param page: Page        :param step: UICaseStepsModel        :param logger:LogWriter        :param em:ExtractManager        :return:        """        match step.method.strip():            case SMethod.GOTO:                return await CustomizeMethod.to_goto(page, step.value, logger, em)            case SMethod.WAIT_FOR_TIMEOUT:                return await CustomizeMethod.to_wait(page, float(step.value), logger)            case SMethod.EVALUATE:                return await CustomizeMethod.to_evaluate(page, step.value.strip(), logger)            case SMethod.FILL:                return await CustomizeMethod.to_fill(page, step, logger, em)            case SMethod.RELOAD:                return await CustomizeMethod.to_reload(page, logger)            case SMethod.UPLOAD_FILE:                return await CustomizeMethod.upload_file(page, step, logger)            case SMethod.GET_TEXT:                return await CustomizeMethod.get_text(page, step, logger, em)            case SMethod.GET_ATTR:                return await CustomizeMethod.get_attr(page, step, logger, em)            case SMethod.CHECK_CONTENT:                return await CustomizeMethod.to_check_content(page, step, logger)            case SMethod.COUNT:                return await CustomizeMethod.to_count(page, step, logger, em)    @staticmethod    async def to_count(page: Page, step: UICaseStepsModel, logger: LogWriter, em: ExtractManager):        try:            locator = await Play.get_locator(page, step)            _c = await locator.count()            await logger.write_log(f"count >>  locator number :{_c}")            if step.value:                await em.add_var(step.value, _c)        except Exception as e:            raise e    @staticmethod    async def to_check_content(page: Page, step: UICaseStepsModel, logger: LogWriter):        try:            locator = await Play.get_locator(page, step)            content = await locator.text_content()            if content and content.strip() != "-":                await logger.write_log(f"has content text :{content}")                return            else:                await logger.write_log(f"not has content text")                raise Exception("【CHECK_CONTENT】断言失败 ❌ 元素无文案")        except Exception as e:            raise e    @staticmethod    async def get_attr(page: Page, step: UICaseStepsModel, logger: LogWriter, em: ExtractManager):        """        获取locator上的属性        :param page:        :param step:        :param logger:LogWriter        :param em:ExtractManager        :return:        """        try:            try:                name, value = step.value.split(";")            except Exception:                await logger.write_log(f"提取变量失败 ⚠️ :{step.value}")                raise Exception(f"提取变量失败 ⚠️ :{step.value}")            locator = await Play.get_locator(page, step)            attr = await locator.get_attribute(name)            if attr:                tempVariable = {                    value.strip(): attr.strip()                }                await logger.write_log(f"提取变量 ✅ {tempVariable}")                await em.add_var(key=step.value.strip(), value=attr.strip())        except Exception as e:            raise e    @staticmethod    async def get_text(page: Page, step: UICaseStepsModel, logger: LogWriter, em: ExtractManager):        """        获取locator上的文案        :param page:        :param step:        :param logger:LogWriter        :param em:ExtractManager        :return:        """        try:            if step.value:                locator = await Play.get_locator(page, step)                text = await locator.text_content()                tempVariable = {                    step.value.strip(): text.strip()                }                await logger.write_log(f"提取变量 ✅ {tempVariable}")                await em.add_var(key=step.value.strip(), value=text.strip())            else:                pass        except Exception as e:            raise e    @staticmethod    async def upload_file(page: Page, step: UICaseStepsModel, logger: LogWriter):        """        上传文件        :param page:        :param step:        :param logger:LogWriter        :return:        """        try:            locator = await Play.get_locator(page, step)            if step.value == "xlsx":                await locator.set_input_files(bj_file)            else:                await locator.set_input_files(FilePath)            await logger.write_log("上传附件 ✅")        except Exception as e:            raise e    @staticmethod    async def to_reload(page: Page, logger: LogWriter):        """        页面刷新        :param page:        :param logger:LogWriter        :return:        """        await logger.write_log(">> reload")        await page.reload()    @staticmethod    async def to_fill(page: Page, step: UICaseStepsModel,                      logger: LogWriter, em: ExtractManager):        """        输入方法特殊处理        fill 前 先清空        查询变量提取。进行替换        :param page:Page        :param step:UICaseStepsModel        :param logger:LogWriter        :param em:ExtractManager        :return:        """        try:            locator = await Play.get_locator(page, step)            # 找到元素方法            fill_value = await em.transform_target(step.value)            await locator.fill(str(fill_value))            await logger.write_log(f"输入 >> {fill_value}")        except Exception as e:            raise e    @staticmethod    async def to_evaluate(page: Page, js: str, logger: LogWriter):        """        执行js        :param page:        :param logger:LogWriter        :param js:        :return:        """        try:            result = await page.evaluate(js)            await logger.write_log(f">> evaluate:  '{js}' result: {result}")        except Exception as e:            raise e    @staticmethod    async def to_wait(page: Page, t: float, logger: LogWriter):        """        等一会        :param page:        :param logger:        :param t        :return:        """        await page.wait_for_timeout(t)    @staticmethod    async def to_goto(page: Page, url: str, logger: LogWriter,                      em: ExtractManager) -> Page:        """        :param page:Page        :param url: 跳转        :param logger: LogWriter        :param em:ExtractManager        :return:        """        url = await em.transform_target(url)        await logger.write_log(f"执行 >> 打开地址:'{url}'")        try:            await page.goto(url, wait_until="load")            await page.wait_for_load_state()        except Exception as e:            log.error(f"An error occurred: {e}")            raise e    @staticmethod    async def to_screenshot(page: Page, logger: LogWriter) -> str:        """        截图        :param page: Page        :param logger:LogWriter        :return:        """        try:            fileDate = GenerateTools.getTime(2)            fileName = f"{GenerateTools.uid()}.jpeg"            path = os.path.join(Config.ROOT, "play_error_shot", fileDate, fileName)            await page.screenshot(                path=path,                full_page=True)            await logger.write_log(f"完成失败截图✅")            return path        except Exception as e:            log.error(e)            await logger.write_log(f"截图失败❌ {str(e)}")            await page.keyboard.press("Enter")class PlayKeyboard:    @staticmethod    async def keyboard(page: Page, step: UICaseStepsModel, logger: LogWriter):        method = step.method.strip().split(".")[-1]        await logger.write_log(f"use keyboard {method}")        return await getattr(PlayKeyboard, method)(page, step, logger)    @staticmethod    async def press(page: Page, step: UICaseStepsModel, logger: LogWriter):        """        键盘按键        :param page:        :param step:        :param logger:LogWriter        :return:        """        try:            await page.keyboard.press(step.value)            await logger.write_log(f"键盘按键 >> {step.value}")        except Exception as e:            raise eclass Play:    """    PlayWright API    """    @staticmethod    async def api_on(page: Page,                     step: UICaseStepsModel,                     logger: LogWriter,                     em: ExtractManager):        """        interface 单次执行        :param page:        :param step:        :param logger:LogWriter        :param em:ExtractManager        :return:        """        method = step.method.strip().split(".")[-1]        try:            jpStr, variableName = step.value.strip().split(";")        except ValueError:            raise ValueError(f"输入值 {step.value}格式错误;请检查")        async def on_response(response):            if step.api_url in response.url:                await logger.write_log("监听成功✅")                await logger.write_log(f"status_code =  {response.status}")                await logger.write_log(f"url =  {response.url}")                try:                    _body = await response.json()                    jp = MyJsonPath(_body, jpStr)                    value = await jp.value()                    await logger.write_log(f"获取变量 >> ✅ {variableName} = {value}")                    await em.add_var(variableName, value)                    log.debug(em.variables)                except JSONDecodeError as e:                    await logger.write_log(f"解析响应失败 ❌ >> {str(e)}")                    await em.add_var(variableName, None)                    return                log.debug(_body)        async def on_request(request):            pass        match method:            case "request":                page.on("request", on_request)            case "response":                await logger.write_log(f"添加接口响应监听 >> {step.api_url}")                page.on("response", on_response)    @staticmethod    async def execute_locator_method(locator_func: Callable, value: str = None):        """        locator().fun(） 执行        :param locator_func:        :param value:        :return:        """        return await locator_func(value) if value else await locator_func()    @staticmethod    async def play(page: Page, step: UICaseStepsModel,                   logger: LogWriter, em: ExtractManager):        """        页面元素操作        区分操作方式是否要输入值        :param page: Page        :param logger:LogWriter        :param step: UICaseStepsModel        :param em: ExtractManager        :return:        """        try:            # 特殊方法处理            if step.method.strip() in SMethod.__attr__:                return await CustomizeMethod.special_method_processing(                    page=page,                    step=step,                    logger=logger,                    em=em)            else:                locator = await Play.get_locator(page, step)                # 找到元素方法                element_method = getattr(locator, step.method)                # 执行方法                return await Play.execute_locator_method(element_method, step.value)        except Exception as e:            raise e    @staticmethod    async def new_page(page: Page, step: UICaseStepsModel):        """        actions On New Page        :param page:        :param step:        :return:        """        try:            async with page.expect_popup() as p:                locator = await Play.get_locator(page, step)                # 找到元素方法                element_method = getattr(locator, step.method)                # 执行方法                await Play.execute_locator_method(element_method, step.value)            return await p.value        except Exception as e:            log.error(e)            raise e    @staticmethod    async def to_expect(page: Page, step: UICaseStepsModel,                        logger: LogWriter, em: ExtractManager):        """        do Assert        expectMethod = step method            ("expect.to_have_title",            "expect.to_have_attribute")        PageAssertions 支持            to_have_title            not_to_have_title            to_have_url            not_to_have_url        LocatorAssertions 支持            ...        :param page: Page        :param step: UICaseStepsModel        :param logger:LogWriter        :param em:ExtractManager        :return:        """        expect.set_options(timeout=1000)        method = step.method.split(".")[-1]        # PageAssertions        if method in PageAssertions.__dict__:            await getattr(expect(page), method)(step.value)        elif method in SMethod.__attr__:            await CustomizeMethod.to_check_content(page, step, logger)        # LocatorAssertions        else:            locator = await Play.get_locator(page, step)            expect_method = getattr(expect(locator), method)            expect_value = await em.transform_target(step.value)            if expect_value:                await logger.write_log(                    f">>expect_value: {expect_value}"                )            if isinstance(expect_value, (int, float)):                expect_value = str(expect_value)            await expect_method(expect_value) if step.value else await expect_method()    @staticmethod    async def get_locator(page: Page, step: UICaseStepsModel) -> Locator:        """        获取 page locator        区分是否在iframe上        并滚动到对应元素        :param page: Page        :param step: 步骤        :return: Locator        """        try:            if step.iframeName:                locator = page.frame_locator(step.iframeName).locator(step.locator)            else:                locator = page.locator(step.locator)            await Play.to_scroll(locator)            return locator        except Exception as e:            raise e    @staticmethod    async def to_scroll(locator: Locator):        try:            await locator.scroll_into_view_if_needed()        except Exception as e:            pass